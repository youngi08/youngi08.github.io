{"meta":{"title":"Hello","subtitle":"youngi's IT Blog","description":null,"author":"Inyoung Park","url":"https://youngi08.github.io"},"pages":[],"posts":[{"title":"MIC-make-tizen-image","slug":"tizen-MIC-make-image","date":"2017-09-04T02:21:48.000Z","updated":"2017-09-04T02:25:06.000Z","comments":true,"path":"2017/09/04/tizen-MIC-make-image/","link":"","permalink":"https://youngi08.github.io/2017/09/04/tizen-MIC-make-image/","excerpt":"","text":"참고 사이트:https://source.tizen.org/ko/documentation/developer-guide/getting-started-guide/creating-tizen-images-michttps://wiki.tizen.org/wiki/Modify_Emulator_Image KickckStart File 다운로드http://download.tizen.org/ 에서 버전에 맞는 KickStart File을 다운로드 해야 한다. i586 mobile 버전 기준1$ wget http://download.tizen.org/snapshots/tizen/mobile/tizen-mobile_20150613.2/images/emulator32-wayland/mobile-emulator32-wayland/tizen-mobile_20150613.2_mobile-emulator32-wayland.ks Tizen Image 만들기 1$ gbs createimage --ks-file=tizen-mobile_20150613.2_mobile-emulator32-wayland.ks Emulator Image 수정하기tizen 다운받은 디렉토리안에 mic-output 폴더에서 ~.tar.gz 압축풀면 platform.img가 있다. -&gt; 최근 버전 경우(mobile)는 ~.tar.gz 압축을 풀면 emulator-rootfs.img emulator-sysdata.img emulator-user.img이 들어있다. 이 경우에는 qemu-img로 빌드 할때1$ ~/tizen-sdk/tools/emulator/bin/qemu-img convert -O qcow2 emulator-rootfs.img emulator-sysdata.img emulator-user.img emulimg.3.0.x86 하면 제대로 런치화면에서 작동한다. 빌드할때 자동으로 Emulator Image를 만들어주고 싶을때는1$ gbs build -A i586 -R http://download.tizen.org/snapshots/tizen/ivi/latest/repos/emulator/packages/ --define \"with emulator\" --overwrite --include-all Mobile 버전의 경우는 emulator도 32/64bit 로 나뉘어져있다. Tizen SDK에서 img파일을 열어주면 된다! https://wiki.tizen.org/wiki/Tizen_IVI_SDK 출처: http://kisys.tistory.com/entry/Tizen-MIC를-이용한-Tizen-Image-만들기 [HelloWorld!]","categories":[{"name":"tizen","slug":"tizen","permalink":"https://youngi08.github.io/categories/tizen/"}],"tags":[]},{"title":"보안 | PKI","slug":"6-2-PKI","date":"2017-09-04T01:36:33.000Z","updated":"2017-09-04T02:10:38.000Z","comments":true,"path":"2017/09/04/6-2-PKI/","link":"","permalink":"https://youngi08.github.io/2017/09/04/6-2-PKI/","excerpt":"","text":"PKI PKI(Public-Key Infrastructure) 공개키 알고리즘을 위한 키 관리 구조 제공 서비스 기밀성, 접근제어, 무결성, 인증, 부인방지 구성요소 인증기관(CA, Certification Authority) 인증정책을 수립하고, 인증서 및 인증서 효력정지 및 폐기목록을 관리하며, 다른 CA와의 상호 인증 제공 정책 승인기관(PPA, Policy Approving Authority) 공개키 기반 구조 전반에 사용되는 정책과 절차 생성 수립 하위 기과들의 정책 준수 상태 및 적정성 감사 정책 인증기관(PCA, Policy Certification Authority) PAA 아래 계층으로 자신의 도메인 내의 사용자와 인증기관이 따라야 할 정책 수립 인증기관의 공개키를 인증하고 인증서, 인증서 폐지 목록 등 관리 등록기관 인증기관과 멀리 떨어져 있는 사용자들을 위해 인증기관과 사용자 사이에 등록기관을 두어 인증기관 대신 사용자들의 인증서 신청 시 그들의 신분과 소속을 확인하는 기능 수행 저장소 사용자의 인증서를 저장하는 저장소의 역할을 하는 일종의 데이터베이스 사용자 PKI 내의 사용자는 사람뿐만 아니라 사람이 이용하는 시스템 모두 의미 PKI의 형태 계층구조 네트워크 구조 혼합형 구조 PKI의 주요 관리 대상 인증서(PKC, Public-Key Certiticate) 한 쌍의 공개키/개인키와 특정 사람/기관을 연결시켜 주는 것을 보증해줌 공개키 인증서에는 이름, 소속, 메일 주소 등의 개인정보 및 그 사람의 공개키가 기재되고, 인증기관의 개인키로 전자서명 되어있음 인증서 표준 규격 X.509 인증서의 작성, 교환을 수행할 때의 표준 규격 X.509 인증서 폐지 목록 프로파일 CRL(Certification Revocation List) 폐지된 인증서들에 대한 목록 인증서 폐지 사유 사용자 개인키가 노출되었거나 훼손된 것으로 여겨진다 CA가 사용자를 더 이상 인증해줄 수 없다 CA의 인증서가 노출되었거나 훼손된 것으로 여겨진다 인증서 운영 프로토콜 온라인 인증서 상태 검증 프로토콜(OCSP, Online Certiticate Status Protocol) 실시간으로 인증서의 상태 정보를 확인할 수 있는 효율적인 방법 구성 요소 OCSP 클라이언트, OCSP 서버, 인증 서버로 구성 서버 기반 인증서 검증 프로토콜(SCVP, Simple Certitication Validation Protocol) SCVP 서버를 이용하여 클라이언트의 인증서 처리에 대한 부담을 줄여 줌 SCVP 서버는 인증서의 유효성 혹은 신뢰할 수 있는 인증서의 체인 등 인증서에 관한 가치 있는 다양한 정보 제공","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 해시함수와 응용","slug":"5-hash-functions-and-applications","date":"2017-09-03T12:02:00.000Z","updated":"2017-09-03T14:06:09.000Z","comments":true,"path":"2017/09/03/5-hash-functions-and-applications/","link":"","permalink":"https://youngi08.github.io/2017/09/03/5-hash-functions-and-applications/","excerpt":"","text":"일방향 해시함수 일방향 해시함수 해시함수는 임의의 길이를 갖는 메시지를 입력으로 하여 고정된 길이의 해시 값 또는 해시 코드라 불리는 값을 출력하는 함수 해시함수 h는 임의의 길이의 문자열을 고정된 길이를 갖는 n비트 문자열로 대응 h: D(정의역) -&gt; R(치역) 다대일 대응 함수 (충돌이 반드시 존재함 의미) 특징 고정길이의 해시값 계산 해시값 고속 계산 일방향성 메시지에 따라 해시값 달라짐 충돌(collision) : 2개의 다른 메시지가 같은 해시값을 갖는 것 일방향 해시함수를 무결성 확인에 사용하기 위해서는 충돌이 발견되어서는 안됨 해시함수의 보안 요구사항 해시 값 h = H(x) : x는 함수 H를 사용한 해시함수 결과가 h인 데이터 블록 프리이미지(입력되는 이미지) 저항성(역상 저항성) 어떠한 코드 h에 대해서도 H(x)=h인 x를 찾는 것은 계산적으로 실행 불가능 제2프리이미지 저항성(두 번째 역상 저항성, 약한 충돌 내성) 메시지를 쉽게 위조할 수 없도록 하는 성질 어떠한 블록 x에 대해서도, H(y)=h(x)인 y=/x인 것을 찾는 것이 계산적으로 실행 불가능 충돌 저항성(강한 충돌 내성) 동일한 다이제스트를 가지는 2개의 메시지를 구하지 못하도록 하는 것 H(x)=h(y)인 어떤(x,y)짝을 찾는 것이 계산적으로 실행 불가능 키가 없는 해시함수 전용함수(새로 만드는 해시함수) 메시지 다이제스트(Message Digest)(MD2 -&gt; MD4 -&gt; MD5) MD5는 메시지를 512비트로 된 블록들로 나누고 128비트 다이제스트 출력 128비트 메시지 다이제스트는 충돌 공격에 내성을 갖기에 길이가 너무 짧다고 알려짐 SHA(Secure Hash Algorithm) MD4 모델 기반, MD5보다 조금 느리지만 좀더 안전 블록암호 기반 해시함수 반복 암호학적 해시함수 안에 사용되는 압축함수 자리에 대칭피 블록암호 사용 새로운 압축함수 생성 필요 없이 DES나 AES처럼 검증된 여러 개의 대칭키 알고리즘을 일방향 함수로 사용 가능 모듈 연산에 기반을 둔 해시함수 압축 함수의 기반을 모듈 연산의 반복적인 수행에 두고 있는 해시함수 장점 : 하드웨어나 소프트웨어 자체에 내장된 모듈 연산 사용 가능 단점 : 속도가 빠르지 않고 안전성 연구에 대한 역사가 짧음 키를 사용하는 해시함수 메시지 인증 기능을 가진 함수 함수 자체의 안정성과 키의 비밀성에 안전성 둠 블록 암호에 기반을 둔 메시지 인증 알고리즘 CBC(Cipher Block Chaining) 모드 이용 메시지 인증코드(MAC) 메시지 인증코드(MAC) 무결성을 확인하고 메시지에 대한 인증을 하는 기술 임의 길이의 메시지와 송신자 및 수신자가 공유하는 키라는 2개의 입력을 기초로 해서 고정 비트길이의 출력(MAC 값)을 계산하는 함수 블록 암호나 해시 함수에 기반을 두기 때문에 전자 서명보다 훨씬 빠름 MAC의 키 배송 문제 MAC에서는 송신자와 수신자가 키를 공유할 필요가 있다 송신자와 수신자가 키를 공유할 필요가 있다는 것은 대칭키 암호 때의 키 배송 문제와 같은 문제가 메시지 인증코드에서도 일어남을 의미 변경 감지 코드(MDC, Modification Detection Code) 메시지의 무결성을 보장하는 메시지 다이제스트","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 전자서명","slug":"6-1-digital-signatures","date":"2017-09-03T11:44:40.000Z","updated":"2017-09-04T01:36:01.000Z","comments":true,"path":"2017/09/03/6-1-digital-signatures/","link":"","permalink":"https://youngi08.github.io/2017/09/03/6-1-digital-signatures/","excerpt":"","text":"전자서명 전자서명의 형식 공개키 암호방식을 이용한 공개키 서명방식 관용 암호방식을 이용한 중재서명방식 전자서명 과정 송신자는 서명 알고리즘을 이용해서 메시지에 서명을 한다 수신자는 메시지와 서명을 받고 이들에 검증 알고리즘을 적용한다 전자서명의 주요 기능 위조 불가 서명자 인증 부인방지 변경 불가 재사용 불가 전자서명 구조 RSA 전자서명 구조 메시지에 서명을 하고 검증 할 수 있음 ElGamal 전자서명 구조 이산대수 문제를 이용한 최초의 서명 방식 Schnorr 전자서명 구조 서명의 크기를 줄이기 위해 Elgmal 기반으로 새로운 구조 제안 전자서명 표준 미국의 전자서명 표준 ElGamal 전자 서명 개방 방식으로 서명과 검증에 소요되는 계산량 획기적으로 줄인 방식 전자서명 방식 메시지 복원형 전자서명 서명자가 자신의 개인키를 이용하여 메시지를 암호화하여 전송하면 검증자가 서명자의 공개키를 이용하여 서명된 암호문 복호화 기존의 공개키 암호방식을 이용 부가형 전자 서명 임의의 길이로 주어진 메시지를 해시 알고리즘을 이용하여 일정한 길이로 압축하고, 해시한 결과에 서명자의 개인키를 이용하여 전자서명하고 메시지에 덧붙여 전송 메시지 전체를 암호화하는 대신에 일방향 해시함수를 사용하여 메시지의 해시값을 구하고, 그 해시값을 암호화(해시값에 서명)하도록 함 특수 전자서명 부인방지 전자서명 자체 인증 방식을 배제시켜 서명을 검증할 때 반드시 서명자의 도움이 있어야 검증 가능 의뢰 부인방지 서명 수신자 지정 서명 지정된 수신자만이 서명을 학인할 수 있고 필요시 제3자에게 그 서명이 서명자에 의해 자신에게 발행된 서명임을 증명할 수 있게 함 은닉 서명(블라인드 서명) 서명문의 내용을 숨기는 서명 방식으로 제공자의 신원과 서명문을 연결시킬 수 없는 익명성 유지 위임 서명 서명자를 대신해서 대리로 서명할 수 있도록 구성한 서명 방식 다중 서명 동일한 전자문서에 여러 사람이 서명하는 것 전자 봉투 전달하고자 하는 메시지를 암호화하여 한 사람을 통해서 보내고, 암호화키는 다른 사람에게 가져가게 하는 것 전자서명의 응용 보안 공지 소프트웨어의 다운로드 공개키 인증서 전자투표 전자투표 시스템 구현을 위한 요구사항 완정성, 비밀성, 재사용 불가, 공정성, 적임성, 검증성, 강건성 전자투표 방식 투표소 전자투표(PSEV, Poll Site E-Voting) 투표소에 선거 관리자가 없고 기기에 전자 인증 장치를 설치해 관리 부분을 해결 원격 인터넷 투표(REV, Remote Internet E-Voting) 기술적 위험이 높고 관리인 없이 자유롭게 투표하므로 비밀투표 침해가능성 있음 전자입찰 시스템 요구사항 독립성, 비밀성, 무결성, 공평성, 안전성 문제점 네트워크상의 메시지 유출 입찰자와 서버 사이의 공모 입찰자간의 공모 입찰자와 입찰 공무자간의 공모","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 대칭키 암호","slug":"3-symmetric-key","date":"2017-09-03T11:18:03.000Z","updated":"2017-09-03T12:05:58.000Z","comments":true,"path":"2017/09/03/3-symmetric-key/","link":"","permalink":"https://youngi08.github.io/2017/09/03/3-symmetric-key/","excerpt":"","text":"대칭키 암호 현대 블록 암호의 구성요소 확산 평문의 통계적 성질을 암호문 전반에 퍼뜨려 숨김(암호문과 평문사이의 관계를 숨김) 혼돈 암호문과 키의 상관관계를 숨김-&gt; 만족시키기 위해 전치요소(P-박스), 치환요소(S-박스) 설계 P-박스 전치 암호 병렬적 수행 단순(straight) 확장(expansion) n비트를 입력받아 m비트를 출력하는 P-박스로서 n&gt;m을 만족한다 축소(compression) n비트를 입력받아 m비트를 출력하는 P-박스로서 n&lt;m을 만족한다 역함수의 존재성 단순 P-박스는 역함수가 존재한다 축소 P-박스와 확장 P-박스는 역함수가 존재하지 않는다 S-박스 치환 암호의 축소 모형, 입/출력 개수 달라도 됨 swap, shift, combine 합성 암호 shamon 확률을 기초로 한 정보이론의 창시자 일회용 패드의 안정성 증명 혼돈, 확산 정의 라운드 반복적으로 사용되는 합성(S,P 박스 / 확산, 혼돈) 암호 Feistel 암호 DES를 포함한 대칭 블록 암호 알고리즘의 기반이 되는 구조 SPN 구조 입력을 여러 개의 소블록으로 나누고 각 소블록을 S-box로 입력하여 대치시키고 S-box의 출력을 P-box로 전치하는 과정을 반복하는 방식 DES(Data Encryption Standard)","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 암호학 개요","slug":"2-cryptography-overview","date":"2017-09-03T08:13:01.000Z","updated":"2017-09-03T12:55:18.000Z","comments":true,"path":"2017/09/03/2-cryptography-overview/","link":"","permalink":"https://youngi08.github.io/2017/09/03/2-cryptography-overview/","excerpt":"","text":"암호학의 개본 개념 암호약속된 당사자 또는 집단에서만 암호문에 내포된 내용을 알 수 있게 하는 일종의 문서 암호학평문을 다른 사람이 알아볼 수 없는 암호문으로 만들고 특정한 비밀키를 알고 있는 사람만이 다시 평문으로 복원시킬 수 있도록 하는 암호 기술과 이를 제3자(도청자)가 해독하는 방법을 분석하는 암호해독에 관하여 연구하는 학문 암호에서 사용하는 이름 앨리스와 밥(Alice and Bob) - 송신자와 수신자 이브(Eve) - 도청자, 소극적 공격자 -&gt; 암호문 스틸 맬로리(Mallory) - 악의를 가진 공격자(재전송) 트렌트(Trent) - 신뢰할 수 있는 중재자, 중립적 위치에 있는 제3자 빅터(Victor) - 의도된 거래나 통신이 실제로 발생했음을 검증할 때 등장 암호화와 복호화 평문 - 암호화하기 전의 메시지 암호문 - 암호화 한 후의 메시지 앨리스와 밥은 암호라는 기술을 사용해서 메일의 기밀성(비밀성) 을 유지 암호화 C = Ek (P) : 평문 P를 키 K로 암호화하여(E) 암호문 C를 얻는다 복호화 P = Dk (C) : 암호문 C를 키 K로 복호화하여(D) 평문 P를 얻는다 암호 기법의 분류 치환암호 비트, 문자 또는 문자의 블록을 다른 비트, 문자 또는 블록으로 대체 평문의 문자를다른 문자로 교환하는 규칙 전치암호 비트, 문자 또는 블록이 원래의 의미를 감추도록 재배열 문자 집합 내부에서 자리를 바꾸는 규칙 블록 암호 평문을 일정한 크기의 블록으로 잘라낸 후 암호화 알고리즘을 적용하여 암호화 어느 특정 비트 수의 집합 을 한번에 처리하는 암호 알고리즘 스트림 암호 데이터 흐름(스트림)을 순차적으로 처리해가는 암호 알고리즘의 총칭히며, 암호화 방식은 평문과 키 스트림을 XOR하여 생성 링크 암호화 헤더를 포함한 모든 데이터를 암호화 물리 계층과 데이터 링크 계층에서 암호화 종단간 암호화 헤더(라우팅)는 암호화 하지 않음 애플리케이션 계층에서 암호화 하드웨어 암호 시스템컴퓨터와 통신기기의 내부 버스와 외부 인터페이스에 전용 암호 처리용 하드웨어를 설치하여 데이터를 암호화 소프트웨어 암호 시스템암호처리용 소프트웨어를 사용한 데이터 암호화 중요 암호기술에 대한 개괄 대칭키 암호 : 암호화 할 때 사용하는 키와 복호화 할때 사용하는 키가 동일 비대칭키 암호 : 암호화 할 때 사용하는 키와 복호화 할 때 사용하는 키가 다름 암호학자의 도구상자 하이브리드 암호시스템 : 대칭키 암호 + 공개키 암호 일방향 해시함수 : 해시 값 메시지 인증코드 : 무결성, 인증제공 전자서명 스푸핑, 변경, 부인 이라는 위협 방지 무결성 확인, 인증과 부인 방지 의사 난수 생성기 : 키 생성 기타 암호 기술들 스테가노 그래피전달하려는 기밀 정보를 이미지 파일이나 MP3 파일 중에 암호화 해 숨기는 심층 암호 기술 감추어진 기록 워터마크원본의 내용을 왜곡하지 않는 범위 내에서 혹은 사용자가 인식하지 못하도록 저작권 정보를 디지털 콘텐츠에 삽입하는 기술 핑거프린팅디지털 콘텐츠를 구매할 때 구매자의 정보를 삽입하여 불법 배포 발견시 최초의 배포자를 추적할 수 있게 하는 기술 암호 분석(암호 해독) 개요 정규참여자가 아닌 제 3자가 암호문으로 부터 평문을 찾으려는 시도 케르히 호프의 원리암호 시스템의 안정성은 암호 알고리즘의 비밀을 지키는데 의존되어서는 안되고, 키의 비밀을 지키는데 의존되어야 한다는 원리 암호 분석의 분류 암호문 단독 공격(COA, Ciphertext Only Attack) 어떤 암호문을 얻어서 대응되는 평문과 키를 찾는 것 기지 평문 공격(KPA, ) 여러개의 평문/암호문의 쌍을 얻어 Alice -&gt; Bob 다음 메시지 알아내는데 사용 선택 평문 공격(CPA) Eve가 Alice의 컴퓨터에 접속할 수 있다면 공격자는 평문/암호문 쌍으로 평문에 해당하는 암호문을 얻어 키나 평문을 추정하여 암호 해독 선택 암호문 공격(CCA) Eve가 Bob의 컴퓨터에 접속할 수 있다면 암호해독자가 암호 복호기에 접근 할 수 있어 암호문을 선택하면 그 암호문에 대한 평문을 얻어 암호를 해독","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | start","slug":"0-security-start","date":"2017-09-03T07:06:19.000Z","updated":"2017-09-04T02:26:23.000Z","comments":true,"path":"2017/09/03/0-security-start/","link":"","permalink":"https://youngi08.github.io/2017/09/03/0-security-start/","excerpt":"","text":"","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 정보보호관리의 개념","slug":"1-security-overview","date":"2017-09-03T07:04:53.000Z","updated":"2017-09-03T08:37:47.000Z","comments":true,"path":"2017/09/03/1-security-overview/","link":"","permalink":"https://youngi08.github.io/2017/09/03/1-security-overview/","excerpt":"","text":"정보보호 정보의 수집, 가공, 저장, 검색, 송민, 수신 중에 발생하는 정보의 훼손, 변조, 유출 등을 방지하기 위한 관리적, 기술적 수단, 또는 그러한 수단으로 이루어지는 행위 정보의 가용성, 보안 측면에서 정보보호란 정보의 활용과 정보의 통제 사이에서 균형감각을 갖는 행위 정보 보호의 목표 기밀성 (Confidentiality) 오직 인가된 사람, 프로세스, 시스템 만이 알 필요성에 근거하여 시스템에 접근해야 한다는 형식 비 인가된 접근으로부터 안전해야 함 무결성 (Integrity) 네트워크를 통하여 송수신 되는 정보의 내용이 불법적으로 생성 또는 변경 되거나 삭제 되지 않도록 보호되어야 하는 성질 비인가된 변경으로 부터 보호되어야 함 가용성 (Availability) 시스템에 지체 없이 동작하도록 하고, 합법적 사용자가 서비스 사용을 거절 당하지 않도록 하는 것 필요할 때 권한이 있는 사용자가 이용할 수 있어야 함 보안 공격(Security attack) 기밀성을 위협하는 공격 스누핑 (Snooping)데이터에 대한 비인가 접근 또는 탈취 트래픽 분석 (Traffic Analysis)데이터를 암호화하여 도청자가 그 데이터를 이해할 수 없게 해도 도청자는 온라인 트래픽을 분석함으로써 다른 형태의 정보를 얻을 수 있다 무결성을 위협하는 공격 변경(메시지 수정) 가장(신분 위장) 재연(재전송) 부인메시지 송신자는 차후에 자신이 메시지를 보냈다는 것을 부인할 수도 있고, 메시지의 수신자는 차후에 메시지를 받았다는 것을 부인할 수 있다 가용성을 위협하는 공격 서비스 거부(Dos)시스템의 서비스를 느리게 하거나 완전히 차단 할 수 있다 소극적 공격과 적극적 공격 소극적 공격(Passive Attack) 소극적 공격에서 공격자의 목표는 단지 정보를 획득하는 것 이는 공격자가 데이터를 변경하거나 시스템에 해를 끼치지 않는 다는 것을 의미한다 적극적 공격(Active Attack) 적극적 공격은 데이터를 바꾸거나 시스템에 해를 입힐 수 있다 공격자가 다양한 방법을 사용하기 때문에 방어하기 보다 탐지하는 것이 더 쉽다 기본 보안용어 정의 자산(Asset) 조직이 보호해야 할 대상으로서 데이터 혹은 자산 소유자가 가치를 부여한 실체 취약점(Vulnerability) 위협의 이용대상으로 관리적, 물리적 기술적 약점 위협(Threat) 보안을 침해하고 손해를 가져올 수 있는 상황, 행위, 이벤트가 존재할 떄의 잠재적 보안 위반 가로채기, 가로막음, 변조, 위조 위험(Risk) 특정 위협이 가져올 피해가 확률적으로 표현되는 예상 손실 노출(Exposure) 위협 주체에게 손실을 드러내 보이는 경우 취약점은 발생 가능한 피해를 노출 시킨다 시점별 통제(Control) 취약점을 감소 시키거나 억제하기 위해 사용되는 메커니즘을 통틀어 일컫는 말 예방통제, 탐지통제, 교정통제","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"크로미움 안드로이드 버전 빌드","slug":"chromium-android-build","date":"2017-08-31T06:12:46.000Z","updated":"2017-08-31T06:39:55.000Z","comments":true,"path":"2017/08/31/chromium-android-build/","link":"","permalink":"https://youngi08.github.io/2017/08/31/chromium-android-build/","excerpt":"","text":"https://www.chromium.org/developers/how-tos/android-build-instructions 사실 저 위에 내용이 다 나와 있지만 헷갈리니 보기 쉽게 설명! depot_tools package 설치 1https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up 소스코드 다운로드! 12$ mkdir ~/chromium &amp;&amp; cd ~/chromium~/chromium$ fetch --nohooks android # This will take 30 minutes on a fast connection 만약 Linux 버전으로 checkout 된 버전이 존재한다면 fetch하지 않고 .gclient 파일에 target_os = [‘android’]를 추가해주면 된다. 소스코드 빌드하기Chromium을 빌드 할 수 있는 방법은 두가지가 있다.GYP build와 GN build가 있는데, 나는 GYP build로! (원래는 GYP build도 됬었는데, 현재는 제대로 지원안하는 것 같고 GN build로 해야 제대로 되는 것 같다) GYP Build 12~/chromium$ echo \"&#123; 'GYP_DEFINES': 'OS=android target_arch=arm', &#125;\" &gt; chromium.gyp_env~/chromium$ gclient runhooks GN Build 123$ export GYP_CHROMIUM_NO_ACTION=1$ ~/chromium/src$ gn args out/Default# out 뒤 폴더명은 Default 대신 다른이름으로 대체가능 1234#파일이 열리면 입력target_os = \"android\"target_cpu = \"arm\" # (default)is_debug = true # (default) 빌드 dependencies 설정 12#빌드에 필요한 시스템 패키지 업데이트~/chromium$ src/build/install-build-deps-android.sh OpenJDK 설정 업데이트-&gt; 없으면 설치법은 (https://www.davidlab.net/ko/tech/how-to-setup-android-dev-env-on-ubuntu-part1/) 123456sudo update-alternatives --config javacsudo update-alternatives --config javasudo update-alternatives --config javawssudo update-alternatives --config javapsudo update-alternatives --config jarsudo update-alternatives --config jarsigner 하위 디렉토리 동기화 1~/chromium/src$ gclient sync APK 빌드&amp; 설치 1~/chromium/src$ . build/android/envsetup.sh device 연결 됬는지 확인! 1third_party/android_tools/sdk/platform-tools/adb devices 빌드를 full browser, Content shell, Webview shell 버전 각각 다르게 할 수 있다. Full browser 빌드 12~/chromium/src$ ninja -C out/Release chrome_public_apk~/chromium/src$ build/android/adb_install_apk.py out/Release/apks/ChromePublic.apk # For gyp 다른 버전들 빌드 방법은 위에 있는 크로미움 사이트에서 확인가능! 설치12~/chromium/src$ build/android/adb_install_apk.py out/Release/apks/ChromePublic.apk # For gyp.~/chromium/src$ CHROMIUM_OUTPUT_DIR=$gndir build/android/adb_install_apk.py $gndir/apks/ChromePublic.apk # For gn","categories":[{"name":"chromium","slug":"chromium","permalink":"https://youngi08.github.io/categories/chromium/"}],"tags":[{"name":"android","slug":"android","permalink":"https://youngi08.github.io/tags/android/"},{"name":"chromium","slug":"chromium","permalink":"https://youngi08.github.io/tags/chromium/"}]},{"title":"알고리즘 | 선택정렬","slug":"algorithm-selection-sort","date":"2017-08-31T06:08:32.000Z","updated":"2017-09-03T12:09:54.000Z","comments":true,"path":"2017/08/31/algorithm-selection-sort/","link":"","permalink":"https://youngi08.github.io/2017/08/31/algorithm-selection-sort/","excerpt":"","text":"선택 정렬(Selection Sort) 정렬 되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환해나가는 방식 선택 정렬의 비교 횟수= (n-1) + (n-2) + (n-3) + … + 1= n(n-1)/2 시간 복잡도 평균, 최악, 최고: O(n^2) 기존의 레코드들이 정렬이 되어 있던, 되어 있지 않던 상관 없이 레코드들의 가장 처음부터 끝까지 비교하는 과정이 모두 같기 때문 동작원리 배열의 첫원소를 key값으로 설정하고 나머지 배열 원소 중 가장 작은 원소를 찾아 교체한다. 교체후에 첫 원소를 제외한 두번째 원소를 키 값으로 설정하고 1단계를 반복한다. 나머지 리스트를 모두 정렬이 될 때까지 1, 2 단계를 반복하여 정렬을 완료한다. 예제코드 1234567891011121314151617void selectionSort()&#123; intDataSet[]=&#123;6,4,2,3,1,5&#125;; int i, j, indexMin, temp; for(i =0; i &lt; n-1; i++)&#123; indexMin=i; for(j = i+1; j &lt; n; j++)&#123; if(list[j] &lt; DataSet[indexMin])&#123; indexMin = j; &#125; &#125; temp=DataSet[indexMin]; DataSet[indexMin]=DataSet[i]; DataSet[i]=temp; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"},{"name":"sort","slug":"algorithm/sort","permalink":"https://youngi08.github.io/categories/algorithm/sort/"}],"tags":[{"name":"sort","slug":"sort","permalink":"https://youngi08.github.io/tags/sort/"}]},{"title":"알고리즘 | 삽입정렬","slug":"algorithm-insert-sort","date":"2017-08-31T05:41:31.000Z","updated":"2017-09-03T12:09:27.000Z","comments":true,"path":"2017/08/31/algorithm-insert-sort/","link":"","permalink":"https://youngi08.github.io/2017/08/31/algorithm-insert-sort/","excerpt":"","text":"삽입정렬(Insert Sort) 데이터 집합을 순회하면서 정렬이 필요한 요소를 뽑아내어 이를 다시 적당한 곳에 삽입해 나가는 알고리즘 아직 정렬 되지 않은 임의의 데이터를 이미 정렬 된 부분의 적절한 위치에 삽입해가며 정렬하는 방식 시간 복잡도 최선 list가 이미 정렬 되어 있는 경우에는 외부 루프 n-1번만 실행되고 각 단계에서 데이터의 이동 없이 1번의 비교 연산만 수행 삽입 정렬은 비교적 정렬이 된 리스트에서는 이동 횟수가 선택 정렬과 버블 정렬에 비해 적게 일어난다는 장점 O(n) 최악 오름차순으로 정렬해야 하는 데이터가 역순으로 내림차순으로 정렬 되어 있다면 각 단계에서 앞에 놓인 데이터들은 전부 한 칸씩 뒤로 이동 해야하고, 외부 루프 안의 각 반복마다 i번 비교가 수행 따라서 데이터의 수가 많고 크기가 큰 경우에는 적합하지 않음 O(n^2) 동작원리 key 값을 기준으로 key의 앞은 정렬이 된 상태이다. i번째 요소를 정렬을 하기 위해서 i번째 배열의 값을 key로 저장을 한다. key값을 기준으로 i-1부터 검사를 하며 key 값보다 값이 클 경우 값을 한 칸씩 오른쪽으로 이동 시킨다. key 값보다 작거나 같은 값이 나올 때까지 2번 과정을 반복한다. 3번 과정에서 key값이 들어갈 위치를 찾으면 key값을 위치에 삽입한다. i+1 번째 배열의 값을 key로 저장 하며 모든 레코드가 정렬될 때 까지 1번 과정부터 반복 예제코드 1234567891011void insertSort()&#123; intDataSet[]=&#123;6,4,2,3,1,5&#125;; for(inti=1; i&lt;n; i++)&#123; key=DataSet[i]; //두 번째 값부터 선택 for(intj=i-1; j&gt;=0&amp;&amp;list[j]&gt;key; j—-)//선택된 값(key)보다 작은 값을 찾는다 DataSet[j+1]=DataSet[j];// 작은 값을 찾은 경우 그 값뒤의 모든 값을 우측으로 이동 DataSet[j+1]=key;//해당되는 곳에 값을 삽입 &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"},{"name":"sort","slug":"algorithm/sort","permalink":"https://youngi08.github.io/categories/algorithm/sort/"}],"tags":[{"name":"sort","slug":"sort","permalink":"https://youngi08.github.io/tags/sort/"}]},{"title":"알고리즘 | 버블정렬","slug":"algorithm-bubbule-sort","date":"2017-08-31T04:01:03.000Z","updated":"2017-09-04T02:25:40.000Z","comments":true,"path":"2017/08/31/algorithm-bubbule-sort/","link":"","permalink":"https://youngi08.github.io/2017/08/31/algorithm-bubbule-sort/","excerpt":"","text":"버블정렬(Bubble Sort) 데이터 집합을 순회하면서 집합 내의 이웃 요소들끼리의 교환을 통해 정렬을 수행 제일 큰 원소를 오른쪽으로 옮기는 방법 버블 정렬의 비교 횟수= (n-1)+(n-2)+…+(n-(n-2))+(n-(n-1))= (n-1)+(n-2)+…+3+2+1 = (n-1)(n/2)비교횟수 T(n)= (n(n-1))/2 시간복잡도 평균, 최악, 최고: O(n^2) 기존의 레코드들이 정렬이 되어 있던, 되어 있지 않던 상관 없이 레코드들의 가장 처음부터 끝까지 비교하는 과정이 모두 같기 때문 개선 방안 -&gt; 정렬되어있는 경우 루프를 취소하고 빠져나오도록 하는 방법 공간복잡도: O(1) 동작원리 이웃 하는 두 레코드를 비교하여 큰 레코드는 우측으로 밀어낸다. 더 이상 이웃 하는 레코드가 없을 때까지 반복한다. 리스트의 가장 우측부터 큰 레코드로 정렬이 된다. 모든 레코드가 정렬이 될 때까지 반복한다. 예제코드 12345678910111213141516void BubbleSort()&#123; int DataSet[]=&#123;6,4,2,3,1,5&#125;; int Length =sizeof(DataSet)/sizeof(DataSet[0]); for(int i=0; i&lt;Length-1; i++)&#123; for(int j=0; j&lt;Length-(i+1); j++)&#123; if(DataSet[j]&gt; DataSet[j+1])&#123; //인접한 두 값을 비교 //정렬되지 않은 두 값 temp = DataSet[j+1]; DataSet[j+1]=DataSet[j]; DataSet[j]=temp; &#125; &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"},{"name":"sort","slug":"algorithm/sort","permalink":"https://youngi08.github.io/categories/algorithm/sort/"}],"tags":[{"name":"sort","slug":"sort","permalink":"https://youngi08.github.io/tags/sort/"}]},{"title":"알고리즘 | start","slug":"algorithm-start","date":"2017-08-31T03:53:59.000Z","updated":"2017-08-31T07:10:59.000Z","comments":true,"path":"2017/08/31/algorithm-start/","link":"","permalink":"https://youngi08.github.io/2017/08/31/algorithm-start/","excerpt":"","text":"Categories 알고리즘 | 개념 자료구조의 분류 선형구조: 선형리스트(배열), 연결 리스트, 스택, 큐, 데크 비선형 구조: 트리, 그래프 정렬(Sorting) 알고리즘 | 정렬 시간복잡도 내부 정렬 소량의 데이터를 주기억장치에만 기억시켜서 정렬하는 방식 알고리즘 | 버블정렬 알고리즘 | 삽입정렬 알고리즘 | 선택정렬 알고리즘 | 퀵정렬 알고리즘 | 합병정렬 알고리즘 | 2-Way 합병 정렬 외부 정렬 대량의 데이터를 보조기억장치에 기억시켜서 정렬하는 방식 대부분 합병정렬(Merge Sort) 기법으로 처리","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/tags/algorithm/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-30T17:55:34.000Z","updated":"2017-08-31T02:22:19.000Z","comments":true,"path":"2017/08/31/hello-world/","link":"","permalink":"https://youngi08.github.io/2017/08/31/hello-world/","excerpt":"","text":"기존 블로그와 에버노트에서 이전중~http://kisys.tistory.com/","categories":[],"tags":[]},{"title":"odroid에 구글 크로미움 포팅하기","slug":"odroid-porting-chromium","date":"2017-08-30T09:41:31.000Z","updated":"2017-08-31T07:20:14.000Z","comments":true,"path":"2017/08/30/odroid-porting-chromium/","link":"","permalink":"https://youngi08.github.io/2017/08/30/odroid-porting-chromium/","excerpt":"","text":"삽질한 것에 비해 굉장히 간단한 방법으로 할 수 있다. 여기에 몇 일을 날렸는가…ㅠㅠ먼저 원리를 제대로 이해하고 했으면 삽질이라고 할 수도 없을 만큼 빠른 시간 안에 할 수 있었을 것이다. 방향을 이상하게 잡아서 삽질하다 보니 굉장히 오래 걸리게 되었다. odroid xu3 보드에 크로미움을 포팅하기 위해서는 arm 32bit용으로 컴파일 해야 한다. Hardkernel 사이트에서 크로스컴파일을 위한 툴체인, 환경을 세팅한다. 내 보드는 xu3이다.http://odroid.com/dokuwiki/doku.php?id=en:xu3_building_kernel 크로미움 크로스컴파일 하기http://unix.stackexchange.com/questions/176794/how-do-i-cross-compile-chromium-for-arm위 사이트 참조! 크로미움 코드를 다운로드 하기 위한 과정은 같다.(1) depot_tools 설치12$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools$ export PATH=$PATH:~/chromium/depot_tools (2) 크로미움 코드 다운로드12$ mkdir chromium &amp;&amp; cd ~/chromium$ fetch --nohooks chromium (3)ARM용 컴파일https://www.olimex.com/forum/index.php?topic=4109.01234./build/install-build-deps.sh --arm &amp;&amp;gclient sync &amp;&amp;GYP_CROSSCOMPILE=1 GYP_DEFINES=\"target_arch=arm arm_float_abi=hard component=shared_library linux_use_gold_flags=1\" gclient runhooks &amp;&amp;ninja -C out/Release chrome","categories":[{"name":"odroid","slug":"odroid","permalink":"https://youngi08.github.io/categories/odroid/"}],"tags":[{"name":"chromium","slug":"chromium","permalink":"https://youngi08.github.io/tags/chromium/"},{"name":"odroid","slug":"odroid","permalink":"https://youngi08.github.io/tags/odroid/"}]},{"title":"Hexo | 마크 다운 문법 정리","slug":"markdown-grammer","date":"2017-08-30T08:28:01.000Z","updated":"2017-09-03T12:45:09.000Z","comments":true,"path":"2017/08/30/markdown-grammer/","link":"","permalink":"https://youngi08.github.io/2017/08/30/markdown-grammer/","excerpt":"","text":"글자 서식 &lt;__문자__&gt; 강조 &lt;_문자_&gt; 기울림 &lt;~~문자~~&gt; 취소 수식 윗 첨자와 아래 첨자 &lt;sup&gt; 윗 첨자sup &lt;sub&gt; 아래 첨자sub 사선","categories":[{"name":"web","slug":"web","permalink":"https://youngi08.github.io/categories/web/"},{"name":"hexo","slug":"web/hexo","permalink":"https://youngi08.github.io/categories/web/hexo/"}],"tags":[]},{"title":"tizen-v8-build","slug":"tizen-v8-build","date":"2015-07-22T02:20:32.000Z","updated":"2017-09-04T02:24:24.000Z","comments":true,"path":"2015/07/22/tizen-v8-build/","link":"","permalink":"https://youngi08.github.io/2015/07/22/tizen-v8-build/","excerpt":"","text":"만약 64비트 환경이라면 먼저 설치하고 시작 하는 것이 정신건강에 좋음 ㅠㅠ (Ubuntu 14.04 기준)1$ sudo apt-get install bison g++-multilib git gperf libxml2-utils make python-networkx zlib1g-dev:i386 zip https://code.google.com/p/v8-wiki/wiki/UsingGit단순히 build만 할 경우에는 Prerequisites 2번의 depot_tools를 설치한 다음 How to Start로 넘어간다 https://code.google.com/p/v8-wiki/wiki/BuildingWithGYP","categories":[{"name":"tizen","slug":"tizen","permalink":"https://youngi08.github.io/categories/tizen/"}],"tags":[]},{"title":"Tizen | Tizen 코드 설치 및 빌드 방법","slug":"tizen-source-build","date":"2015-06-13T14:23:26.000Z","updated":"2017-09-04T02:21:01.000Z","comments":true,"path":"2015/06/13/tizen-source-build/","link":"","permalink":"https://youngi08.github.io/2015/06/13/tizen-source-build/","excerpt":"","text":"GBS, MICS 설치 123$ deb http://download.tizen.org/tools/latest-relase/Ubuntu_14.04 /$ sudo apt-get update$ sudo apt-get install gbs Tizen code repo (Tizen 3.0 기준) mobile 버전 1$ repo init -u ssh://&lt;username&gt;@review.tizen.org:29418/scm/manifest -b tizen -m mobile.xml ivi나 common버전을 받으려면 mobile.xml 대신 ivi.xml/common.xml로 받으면 된다. username은 Gerrit에 등록된 이름 1$ repo sync -j8 Build i586 아키텍처로 빌드1$ gbs build -A i586 --threads=4 --clean-once --exclude=gcc,cmake,filesystem,aul,libmm-sound,libtool -armv7l 아키텍처로 빌드123$ skip_pkgs=\"bash,bzip2-libs,c-ares,cmake,coreutils,diffutils,eglibc,elfutils-libelf,elfutilslibs,elfutils,fdupes,file,findutils,gawk,gmp,libacl,libattr,libcap,libcurl,libfile,libgcc,liblua,libstdc ++,make,mpc,mpfr,ncurses-libs,nodejs,nspr,nss-softokn-freebl,nss,openssl,patch,popt,rpmlibs,rpm-build,sed,sqlite,tar,xz-libs,binutils,gcc,filesystem,aul,libmm- sound,libtool,syspopup,notification,libva,libzypp-bindings,rpm\"$ gbs build -A armv7l --threads=4 --clean-once --exclude=$&#123;skip_pkgs&#125;,filesystem, aul, libmm-sound, libtool build완료하고 난 후에 error: some packages failed to be built 와 같은 에러가 발생하는데 이 에러는 무시해도 영향을 미치지 않는것 같다. 왜 이런 에러가 발생하는지는 모르겠다ㅠ ㅠㅠ Build가 완료되면 RPM파일이 생성되는데 이 파일은 ~/GBS-ROOT/local/repos/tizen3.0_mobile(자신이 받은 버전)/i586(빌드한 아키텍처처)/RPMS 디렉토리에서 확인 가능하다.","categories":[{"name":"tizen","slug":"tizen","permalink":"https://youngi08.github.io/categories/tizen/"}],"tags":[]},{"title":"Tizen | 타이젠 설치법","slug":"tizen-install","date":"2015-05-28T14:36:59.000Z","updated":"2017-09-04T02:21:07.000Z","comments":true,"path":"2015/05/28/tizen-install/","link":"","permalink":"https://youngi08.github.io/2015/05/28/tizen-install/","excerpt":"","text":"타이젠 웹사이트 계정 생성 및 Gerrit등록, 소스코드 다운 받는 법을 자세히 알려준 블로그! 설치중 발생하는 에러 상황 대처법까지 자세히 정리되어있다. 타이젠에 대한 정말정말 알차고 좋은 내용의 포스팅들이 가득하다! http://seoz.egloos.com/3913161 http://miatistory.tistory.com/6","categories":[{"name":"tizen","slug":"tizen","permalink":"https://youngi08.github.io/categories/tizen/"}],"tags":[]}]}