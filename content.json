{"meta":{"title":"Hello","subtitle":"youngi's IT Blog","description":null,"author":"Inyoung Park","url":"https://youngi08.github.io"},"pages":[],"posts":[{"title":"보안 | 전자서명과 PKI","slug":"6-digital-signatures-and-PKI","date":"2017-09-03T11:44:40.000Z","updated":"2017-09-03T11:58:42.000Z","comments":true,"path":"2017/09/03/6-digital-signatures-and-PKI/","link":"","permalink":"https://youngi08.github.io/2017/09/03/6-digital-signatures-and-PKI/","excerpt":"","text":"전자서명 전자서명의 형식 공개키 암호방식을 이용한 공개키 서명방식 관용 암호방식을 이용한 중재서명방식 전자서명 과정 송신자는 서명 알고리즘을 이용해서 메시지에 서명을 한다","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 대칭키 암호","slug":"3-symmetric-key","date":"2017-09-03T11:18:03.000Z","updated":"2017-09-03T11:43:20.000Z","comments":true,"path":"2017/09/03/3-symmetric-key/","link":"","permalink":"https://youngi08.github.io/2017/09/03/3-symmetric-key/","excerpt":"","text":"대칭키 암호 현대 블록 암호의 구성요소 확산 평문의 통계적 성질을 암호문 전반에 퍼뜨려 숨김(암호문과 평문사이의 관계를 숨김) 혼돈 암호문과 키의 상관관계를 숨김-&gt; 만족시키기 위해 전치요소(P-박스), 치환요소(S-박스) 설계 P-박스 전치 암호 병렬적 수행 단순(straight) 확장(expansion) n비트를 입력받아 m비트를 출력하는 P-박스로서 n&gt;m을 만족한다 축소(compression) n비트를 입력받아 m비트를 출력하는 P-박스로서 n&lt;m을 만족한다 역함수의 존재성 단순 P-박스는 역함수가 존재한다 축소 P-박스와 확장 P-박스는 역함수가 존재하지 않는다 S-박스 치환 암호의 축소 모형, 입/출력 개수 달라도 됨 swap, shift, combine 합성 암호 shamon 확률을 기초로 한 정보이론의 창시자 일회용 패드의 안정성 증명 혼돈, 확산 정의 라운드 반복적으로 사용되는 합성(S,P 박스 / 확산, 혼돈) 암호 Feistel 암호 DES를 포함한 대칭 블록 암호 알고리즘의 기반이 되는 구조 SPN 구조 입력을 여러 개의 소블록으로 나누고 각 소블록을 S-box로 입력하여 대치시키고 S-box의 출력을 P-box로 전치하는 과정을 반복하는 방식 DES(Data Encryption Standard)","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 암호학 개요","slug":"2-cryptography-overview","date":"2017-09-03T08:13:01.000Z","updated":"2017-09-03T11:16:22.000Z","comments":true,"path":"2017/09/03/2-cryptography-overview/","link":"","permalink":"https://youngi08.github.io/2017/09/03/2-cryptography-overview/","excerpt":"","text":"암호학의 개본 개념 암호약속된 당사자 또는 집단에서만 암호문에 내포된 내용을 알 수 있게 하는 일종의 문서 암호학평문을 다른 사람이 알아볼 수 없는 암호문으로 만들고 특정한 비밀키를 알고 있는 사람만이 다시 평문으로 복원시킬 수 있도록 하는 암호 기술과 이를 제3자(도청자)가 해독하는 방법을 분석하는 암호해독에 관하여 연구하는 학문 암호에서 사용하는 이름 앨리스와 밥(Alice and Bob) - 송신자와 수신자 이브(Eve) - 도청자, 소극적 공격자 -&gt; 암호문 스틸 맬로리(Mallory) - 악의를 가진 공격자(재전송) 트렌트(Trent) - 신뢰할 수 있는 중재자, 중립적 위치에 있는 제3자 빅터(Victor) - 의도된 거래나 통신이 실제로 발생했음을 검증할 때 등장 암호화와 복호화 평문 - 암호화하기 전의 메시지 암호문 - 암호화 한 후의 메시지 앨리스와 밥은 암호라는 기술을 사용해서 메일의 기밀성(비밀성) 을 유지 암호화 C = Ek (P) : 평문 P를 키 K로 암호화하여(E) 암호문 C를 얻는다 복호화 P = Dk (C) : 암호문 C를 키 K로 복호화하여(D) 평문 P를 얻는다 암호 기법의 분류 치환암호 비트, 문자 또는 문자의 블록을 다른 비트, 문자 또는 블록으로 대체 평문의 문자를다른 문자로 교환하는 규칙 전치암호 비트, 문자 또는 블록이 원래의 의미를 감추도록 재배열 문자 집합 내부에서 자리를 바꾸는 규칙 블록 암호 평문을 일정한 크기의 블록으로 잘라낸 후 암호화 알고리즘을 적용하여 암호화 어느 특정 비트 수의 집합 을 한번에 처리하는 암호 알고리즘 스트림 암호 데이터 흐름(스트림)을 순차적으로 처리해가는 암호 알고리즘의 총칭히며, 암호화 방식은 평문과 키 스트림을 XOR하여 생성 링크 암호화 헤더를 포함한 모든 데이터를 암호화 물리 계층과 데이터 링크 계층에서 암호화 종단간 암호화 헤더(라우팅)는 암호화 하지 않음 애플리케이션 계층에서 암호화 하드웨어 암호 시스템컴퓨터와 통신기기의 내부 버스와 외부 인터페이스에 전용 암호 처리용 하드웨어를 설치하여 데이터를 암호화 소프트웨어 암호 시스템암호처리용 소프트웨어를 사용한 데이터 암호화 중요 암호기술에 대한 개괄 대칭키 암호 : 암호화 할 때 사용하는 키와 복호화 할때 사용하는 키가 동일 비대칭키 암호 : 암호화 할 때 사용하는 키와 복호화 할 때 사용하는 키가 다름 암호학자의 도구상자 하이브리드 암호시스템 : 대칭키 암호 + 공개키 암호 일방향 해시함수 : 해시 값 메시지 인증코드 : 무결성, 인증제공 전자서명 스푸핑, 변경, 부인 이라는 위협 방지 무결성 확인, 인증과 부인 방지 의사 난수 생성기 : 키 생성 기타 암호 기술들 스테가노 그래피전달하려는 기밀 정보를 이미지 파일이나 MP3 파일 중에 암호화 해 숨기는 심층 암호 기술 감추어진 기록 워터마크원본의 내용을 왜곡하지 않는 범위 내에서 혹은 사용자가 인식하지 못하도록 저작권 정보를 디지털 콘텐츠에 삽입하는 기술 핑거프린팅디지털 콘텐츠를 구매할 때 구매자의 정보를 삽입하여 불법 배포 발견시 최초의 배포자를 추적할 수 있게 하는 기술 암호 분석(암호 해독) 개요 정규참여자가 아닌 제 3자가 암호문으로 부터 평문을 찾으려는 시도 케르히 호프의 원리암호 시스템의 안정성은 암호 알고리즘의 비밀을 지키는데 의존되어서는 안되고, 키의 비밀을 지키는데 의존되어야 한다는 원리 암호 분석의 분류 암호문 단독 공격(COA, Ciphertext Only Attack) 어떤 암호문을 얻어서 대응되는 평문과 키를 찾는 것 기지 평문 공격(KPA, ) 여러개의 평문/암호문의 쌍을 얻어 Alice -&gt; Bob 다음 메시지 알아내는데 사용 선택 평문 공격(CPA) Eve가 Alice의 컴퓨터에 접속할 수 있다면 공격자는 평문/암호문 쌍으로 평문에 해당하는 암호문을 얻어 키나 평문을 추정하여 암호 해독 선택 암호문 공격(CCA) Eve가 Bob의 컴퓨터에 접속할 수 있다면 암호해독자가 암호 복호기에 접근 할 수 있어 암호문을 선택하면 그 암호문에 대한 평문을 얻어 암호를 해독","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | start","slug":"security-start","date":"2017-09-03T07:06:19.000Z","updated":"2017-09-03T07:07:41.000Z","comments":true,"path":"2017/09/03/security-start/","link":"","permalink":"https://youngi08.github.io/2017/09/03/security-start/","excerpt":"","text":"","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 정보보호관리의 개념","slug":"1-security-overview","date":"2017-09-03T07:04:53.000Z","updated":"2017-09-03T08:37:47.000Z","comments":true,"path":"2017/09/03/1-security-overview/","link":"","permalink":"https://youngi08.github.io/2017/09/03/1-security-overview/","excerpt":"","text":"정보보호 정보의 수집, 가공, 저장, 검색, 송민, 수신 중에 발생하는 정보의 훼손, 변조, 유출 등을 방지하기 위한 관리적, 기술적 수단, 또는 그러한 수단으로 이루어지는 행위 정보의 가용성, 보안 측면에서 정보보호란 정보의 활용과 정보의 통제 사이에서 균형감각을 갖는 행위 정보 보호의 목표 기밀성 (Confidentiality) 오직 인가된 사람, 프로세스, 시스템 만이 알 필요성에 근거하여 시스템에 접근해야 한다는 형식 비 인가된 접근으로부터 안전해야 함 무결성 (Integrity) 네트워크를 통하여 송수신 되는 정보의 내용이 불법적으로 생성 또는 변경 되거나 삭제 되지 않도록 보호되어야 하는 성질 비인가된 변경으로 부터 보호되어야 함 가용성 (Availability) 시스템에 지체 없이 동작하도록 하고, 합법적 사용자가 서비스 사용을 거절 당하지 않도록 하는 것 필요할 때 권한이 있는 사용자가 이용할 수 있어야 함 보안 공격(Security attack) 기밀성을 위협하는 공격 스누핑 (Snooping)데이터에 대한 비인가 접근 또는 탈취 트래픽 분석 (Traffic Analysis)데이터를 암호화하여 도청자가 그 데이터를 이해할 수 없게 해도 도청자는 온라인 트래픽을 분석함으로써 다른 형태의 정보를 얻을 수 있다 무결성을 위협하는 공격 변경(메시지 수정) 가장(신분 위장) 재연(재전송) 부인메시지 송신자는 차후에 자신이 메시지를 보냈다는 것을 부인할 수도 있고, 메시지의 수신자는 차후에 메시지를 받았다는 것을 부인할 수 있다 가용성을 위협하는 공격 서비스 거부(Dos)시스템의 서비스를 느리게 하거나 완전히 차단 할 수 있다 소극적 공격과 적극적 공격 소극적 공격(Passive Attack) 소극적 공격에서 공격자의 목표는 단지 정보를 획득하는 것 이는 공격자가 데이터를 변경하거나 시스템에 해를 끼치지 않는 다는 것을 의미한다 적극적 공격(Active Attack) 적극적 공격은 데이터를 바꾸거나 시스템에 해를 입힐 수 있다 공격자가 다양한 방법을 사용하기 때문에 방어하기 보다 탐지하는 것이 더 쉽다 기본 보안용어 정의 자산(Asset) 조직이 보호해야 할 대상으로서 데이터 혹은 자산 소유자가 가치를 부여한 실체 취약점(Vulnerability) 위협의 이용대상으로 관리적, 물리적 기술적 약점 위협(Threat) 보안을 침해하고 손해를 가져올 수 있는 상황, 행위, 이벤트가 존재할 떄의 잠재적 보안 위반 가로채기, 가로막음, 변조, 위조 위험(Risk) 특정 위협이 가져올 피해가 확률적으로 표현되는 예상 손실 노출(Exposure) 위협 주체에게 손실을 드러내 보이는 경우 취약점은 발생 가능한 피해를 노출 시킨다 시점별 통제(Control) 취약점을 감소 시키거나 억제하기 위해 사용되는 메커니즘을 통틀어 일컫는 말 예방통제, 탐지통제, 교정통제","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"크로미움 안드로이드 버전 빌드","slug":"chromium-android-build","date":"2017-08-31T06:12:46.000Z","updated":"2017-08-31T06:39:55.000Z","comments":true,"path":"2017/08/31/chromium-android-build/","link":"","permalink":"https://youngi08.github.io/2017/08/31/chromium-android-build/","excerpt":"","text":"https://www.chromium.org/developers/how-tos/android-build-instructions 사실 저 위에 내용이 다 나와 있지만 헷갈리니 보기 쉽게 설명! depot_tools package 설치 1https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up 소스코드 다운로드! 12$ mkdir ~/chromium &amp;&amp; cd ~/chromium~/chromium$ fetch --nohooks android # This will take 30 minutes on a fast connection 만약 Linux 버전으로 checkout 된 버전이 존재한다면 fetch하지 않고 .gclient 파일에 target_os = [‘android’]를 추가해주면 된다. 소스코드 빌드하기Chromium을 빌드 할 수 있는 방법은 두가지가 있다.GYP build와 GN build가 있는데, 나는 GYP build로! (원래는 GYP build도 됬었는데, 현재는 제대로 지원안하는 것 같고 GN build로 해야 제대로 되는 것 같다) GYP Build 12~/chromium$ echo \"&#123; 'GYP_DEFINES': 'OS=android target_arch=arm', &#125;\" &gt; chromium.gyp_env~/chromium$ gclient runhooks GN Build 123$ export GYP_CHROMIUM_NO_ACTION=1$ ~/chromium/src$ gn args out/Default# out 뒤 폴더명은 Default 대신 다른이름으로 대체가능 1234#파일이 열리면 입력target_os = \"android\"target_cpu = \"arm\" # (default)is_debug = true # (default) 빌드 dependencies 설정 12#빌드에 필요한 시스템 패키지 업데이트~/chromium$ src/build/install-build-deps-android.sh OpenJDK 설정 업데이트-&gt; 없으면 설치법은 (https://www.davidlab.net/ko/tech/how-to-setup-android-dev-env-on-ubuntu-part1/) 123456sudo update-alternatives --config javacsudo update-alternatives --config javasudo update-alternatives --config javawssudo update-alternatives --config javapsudo update-alternatives --config jarsudo update-alternatives --config jarsigner 하위 디렉토리 동기화 1~/chromium/src$ gclient sync APK 빌드&amp; 설치 1~/chromium/src$ . build/android/envsetup.sh device 연결 됬는지 확인! 1third_party/android_tools/sdk/platform-tools/adb devices 빌드를 full browser, Content shell, Webview shell 버전 각각 다르게 할 수 있다. Full browser 빌드 12~/chromium/src$ ninja -C out/Release chrome_public_apk~/chromium/src$ build/android/adb_install_apk.py out/Release/apks/ChromePublic.apk # For gyp 다른 버전들 빌드 방법은 위에 있는 크로미움 사이트에서 확인가능! 설치12~/chromium/src$ build/android/adb_install_apk.py out/Release/apks/ChromePublic.apk # For gyp.~/chromium/src$ CHROMIUM_OUTPUT_DIR=$gndir build/android/adb_install_apk.py $gndir/apks/ChromePublic.apk # For gn","categories":[{"name":"chromium","slug":"chromium","permalink":"https://youngi08.github.io/categories/chromium/"}],"tags":[{"name":"android","slug":"android","permalink":"https://youngi08.github.io/tags/android/"},{"name":"chromium","slug":"chromium","permalink":"https://youngi08.github.io/tags/chromium/"}]},{"title":"알고리즘 | 선택정렬","slug":"selection-sort","date":"2017-08-31T06:08:32.000Z","updated":"2017-08-31T07:10:53.000Z","comments":true,"path":"2017/08/31/selection-sort/","link":"","permalink":"https://youngi08.github.io/2017/08/31/selection-sort/","excerpt":"","text":"선택 정렬(Selection Sort) 정렬 되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환해나가는 방식 선택 정렬의 비교 횟수= (n-1) + (n-2) + (n-3) + … + 1= n(n-1)/2 시간 복잡도 평균, 최악, 최고: O(n^2) 기존의 레코드들이 정렬이 되어 있던, 되어 있지 않던 상관 없이 레코드들의 가장 처음부터 끝까지 비교하는 과정이 모두 같기 때문 동작원리 배열의 첫원소를 key값으로 설정하고 나머지 배열 원소 중 가장 작은 원소를 찾아 교체한다. 교체후에 첫 원소를 제외한 두번째 원소를 키 값으로 설정하고 1단계를 반복한다. 나머지 리스트를 모두 정렬이 될 때까지 1, 2 단계를 반복하여 정렬을 완료한다. 예제코드 1234567891011121314151617void selectionSort()&#123; intDataSet[]=&#123;6,4,2,3,1,5&#125;; int i, j, indexMin, temp; for(i =0; i &lt; n-1; i++)&#123; indexMin=i; for(j = i+1; j &lt; n; j++)&#123; if(list[j] &lt; DataSet[indexMin])&#123; indexMin = j; &#125; &#125; temp=DataSet[indexMin]; DataSet[indexMin]=DataSet[i]; DataSet[i]=temp; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/tags/algorithm/"}]},{"title":"알고리즘 | 삽입정렬","slug":"insert-sort","date":"2017-08-31T05:41:31.000Z","updated":"2017-08-31T07:10:56.000Z","comments":true,"path":"2017/08/31/insert-sort/","link":"","permalink":"https://youngi08.github.io/2017/08/31/insert-sort/","excerpt":"","text":"삽입정렬(Insert Sort) 데이터 집합을 순회하면서 정렬이 필요한 요소를 뽑아내어 이를 다시 적당한 곳에 삽입해 나가는 알고리즘 아직 정렬 되지 않은 임의의 데이터를 이미 정렬 된 부분의 적절한 위치에 삽입해가며 정렬하는 방식 시간 복잡도 최선 list가 이미 정렬 되어 있는 경우에는 외부 루프 n-1번만 실행되고 각 단계에서 데이터의 이동 없이 1번의 비교 연산만 수행 삽입 정렬은 비교적 정렬이 된 리스트에서는 이동 횟수가 선택 정렬과 버블 정렬에 비해 적게 일어난다는 장점 O(n) 최악 오름차순으로 정렬해야 하는 데이터가 역순으로 내림차순으로 정렬 되어 있다면 각 단계에서 앞에 놓인 데이터들은 전부 한 칸씩 뒤로 이동 해야하고, 외부 루프 안의 각 반복마다 i번 비교가 수행 따라서 데이터의 수가 많고 크기가 큰 경우에는 적합하지 않음 O(n^2) 동작원리 key 값을 기준으로 key의 앞은 정렬이 된 상태이다. i번째 요소를 정렬을 하기 위해서 i번째 배열의 값을 key로 저장을 한다. key값을 기준으로 i-1부터 검사를 하며 key 값보다 값이 클 경우 값을 한 칸씩 오른쪽으로 이동 시킨다. key 값보다 작거나 같은 값이 나올 때까지 2번 과정을 반복한다. 3번 과정에서 key값이 들어갈 위치를 찾으면 key값을 위치에 삽입한다. i+1 번째 배열의 값을 key로 저장 하며 모든 레코드가 정렬될 때 까지 1번 과정부터 반복 예제코드 1234567891011void insertSort()&#123; intDataSet[]=&#123;6,4,2,3,1,5&#125;; for(inti=1; i&lt;n; i++)&#123; key=DataSet[i]; //두 번째 값부터 선택 for(intj=i-1; j&gt;=0&amp;&amp;list[j]&gt;key; j—-)//선택된 값(key)보다 작은 값을 찾는다 DataSet[j+1]=DataSet[j];// 작은 값을 찾은 경우 그 값뒤의 모든 값을 우측으로 이동 DataSet[j+1]=key;//해당되는 곳에 값을 삽입 &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/tags/algorithm/"}]},{"title":"알고리즘 | 버블정렬","slug":"bubbule-sort","date":"2017-08-31T04:01:03.000Z","updated":"2017-08-31T07:10:58.000Z","comments":true,"path":"2017/08/31/bubbule-sort/","link":"","permalink":"https://youngi08.github.io/2017/08/31/bubbule-sort/","excerpt":"","text":"버블정렬(Bubble Sort) 데이터 집합을 순회하면서 집합 내의 이웃 요소들끼리의 교환을 통해 정렬을 수행 제일 큰 원소를 오른쪽으로 옮기는 방법 버블 정렬의 비교 횟수= (n-1)+(n-2)+…+(n-(n-2))+(n-(n-1))= (n-1)+(n-2)+…+3+2+1 = (n-1)(n/2)비교횟수 T(n)= (n(n-1))/2 시간복잡도 평균, 최악, 최고: O(n^2) 기존의 레코드들이 정렬이 되어 있던, 되어 있지 않던 상관 없이 레코드들의 가장 처음부터 끝까지 비교하는 과정이 모두 같기 때문 개선 방안 -&gt; 정렬되어있는 경우 루프를 취소하고 빠져나오도록 하는 방법 공간복잡도: O(1) 동작원리 이웃 하는 두 레코드를 비교하여 큰 레코드는 우측으로 밀어낸다. 더 이상 이웃 하는 레코드가 없을 때까지 반복한다. 리스트의 가장 우측부터 큰 레코드로 정렬이 된다. 모든 레코드가 정렬이 될 때까지 반복한다. 예제코드 12345678910111213141516void BubbleSort()&#123; int DataSet[]=&#123;6,4,2,3,1,5&#125;; int Length =sizeof(DataSet)/sizeof(DataSet[0]); for(int i=0; i&lt;Length-1; i++)&#123; for(int j=0; j&lt;Length-(i+1); j++)&#123; if(DataSet[j]&gt; DataSet[j+1])&#123; //인접한 두 값을 비교 //정렬되지 않은 두 값 temp = DataSet[j+1]; DataSet[j+1]=DataSet[j]; DataSet[j]=temp; &#125; &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/tags/algorithm/"}]},{"title":"알고리즘 | start","slug":"algorithm-start","date":"2017-08-31T03:53:59.000Z","updated":"2017-08-31T07:10:59.000Z","comments":true,"path":"2017/08/31/algorithm-start/","link":"","permalink":"https://youngi08.github.io/2017/08/31/algorithm-start/","excerpt":"","text":"Categories 알고리즘 | 개념 자료구조의 분류 선형구조: 선형리스트(배열), 연결 리스트, 스택, 큐, 데크 비선형 구조: 트리, 그래프 정렬(Sorting) 알고리즘 | 정렬 시간복잡도 내부 정렬 소량의 데이터를 주기억장치에만 기억시켜서 정렬하는 방식 알고리즘 | 버블정렬 알고리즘 | 삽입정렬 알고리즘 | 선택정렬 알고리즘 | 퀵정렬 알고리즘 | 합병정렬 알고리즘 | 2-Way 합병 정렬 외부 정렬 대량의 데이터를 보조기억장치에 기억시켜서 정렬하는 방식 대부분 합병정렬(Merge Sort) 기법으로 처리","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/tags/algorithm/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-30T17:55:34.000Z","updated":"2017-08-31T02:22:19.000Z","comments":true,"path":"2017/08/31/hello-world/","link":"","permalink":"https://youngi08.github.io/2017/08/31/hello-world/","excerpt":"","text":"기존 블로그와 에버노트에서 이전중~http://kisys.tistory.com/","categories":[],"tags":[]},{"title":"odroid에 구글 크로미움 포팅하기","slug":"porting-chromium-to-odroid","date":"2017-08-30T09:41:31.000Z","updated":"2017-08-31T07:20:14.000Z","comments":true,"path":"2017/08/30/porting-chromium-to-odroid/","link":"","permalink":"https://youngi08.github.io/2017/08/30/porting-chromium-to-odroid/","excerpt":"","text":"삽질한 것에 비해 굉장히 간단한 방법으로 할 수 있다. 여기에 몇 일을 날렸는가…ㅠㅠ먼저 원리를 제대로 이해하고 했으면 삽질이라고 할 수도 없을 만큼 빠른 시간 안에 할 수 있었을 것이다. 방향을 이상하게 잡아서 삽질하다 보니 굉장히 오래 걸리게 되었다. odroid xu3 보드에 크로미움을 포팅하기 위해서는 arm 32bit용으로 컴파일 해야 한다. Hardkernel 사이트에서 크로스컴파일을 위한 툴체인, 환경을 세팅한다. 내 보드는 xu3이다.http://odroid.com/dokuwiki/doku.php?id=en:xu3_building_kernel 크로미움 크로스컴파일 하기http://unix.stackexchange.com/questions/176794/how-do-i-cross-compile-chromium-for-arm위 사이트 참조! 크로미움 코드를 다운로드 하기 위한 과정은 같다.(1) depot_tools 설치12$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools$ export PATH=$PATH:~/chromium/depot_tools (2) 크로미움 코드 다운로드12$ mkdir chromium &amp;&amp; cd ~/chromium$ fetch --nohooks chromium (3)ARM용 컴파일https://www.olimex.com/forum/index.php?topic=4109.01234./build/install-build-deps.sh --arm &amp;&amp;gclient sync &amp;&amp;GYP_CROSSCOMPILE=1 GYP_DEFINES=\"target_arch=arm arm_float_abi=hard component=shared_library linux_use_gold_flags=1\" gclient runhooks &amp;&amp;ninja -C out/Release chrome","categories":[{"name":"odroid","slug":"odroid","permalink":"https://youngi08.github.io/categories/odroid/"}],"tags":[{"name":"chromium","slug":"chromium","permalink":"https://youngi08.github.io/tags/chromium/"},{"name":"odroid","slug":"odroid","permalink":"https://youngi08.github.io/tags/odroid/"}]},{"title":"Hexo | 마크 다운 문법 정리","slug":"markdown-grammer","date":"2017-08-30T08:28:01.000Z","updated":"2017-09-03T08:39:52.000Z","comments":true,"path":"2017/08/30/markdown-grammer/","link":"","permalink":"https://youngi08.github.io/2017/08/30/markdown-grammer/","excerpt":"","text":"글자 서식 &lt;__문자__&gt; 강조 &lt;_문자_&gt; 기울림 &lt;~~문자~~&gt; 취소 수식 윗 첨자와 아래 첨자 &lt;sup&gt; 윗 첨자sup &lt;sub&gt; 아래 첨자sub","categories":[{"name":"hexo","slug":"hexo","permalink":"https://youngi08.github.io/categories/hexo/"}],"tags":[]}]}