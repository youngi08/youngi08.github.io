{"meta":{"title":"Hello","subtitle":"youngi's IT Blog","description":null,"author":"Inyoung Park","url":"https://youngi08.github.io"},"pages":[],"posts":[{"title":"크로미움 안드로이드 버전 빌드","slug":"chromium-android-build","date":"2017-08-31T06:12:46.000Z","updated":"2017-08-31T06:39:55.000Z","comments":true,"path":"2017/08/31/chromium-android-build/","link":"","permalink":"https://youngi08.github.io/2017/08/31/chromium-android-build/","excerpt":"","text":"https://www.chromium.org/developers/how-tos/android-build-instructions 사실 저 위에 내용이 다 나와 있지만 헷갈리니 보기 쉽게 설명! depot_tools package 설치 1https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up 소스코드 다운로드! 12$ mkdir ~/chromium &amp;&amp; cd ~/chromium~/chromium$ fetch --nohooks android # This will take 30 minutes on a fast connection 만약 Linux 버전으로 checkout 된 버전이 존재한다면 fetch하지 않고 .gclient 파일에 target_os = [‘android’]를 추가해주면 된다. 소스코드 빌드하기Chromium을 빌드 할 수 있는 방법은 두가지가 있다.GYP build와 GN build가 있는데, 나는 GYP build로! (원래는 GYP build도 됬었는데, 현재는 제대로 지원안하는 것 같고 GN build로 해야 제대로 되는 것 같다) GYP Build 12~/chromium$ echo \"&#123; 'GYP_DEFINES': 'OS=android target_arch=arm', &#125;\" &gt; chromium.gyp_env~/chromium$ gclient runhooks GN Build 123$ export GYP_CHROMIUM_NO_ACTION=1$ ~/chromium/src$ gn args out/Default# out 뒤 폴더명은 Default 대신 다른이름으로 대체가능 1234#파일이 열리면 입력target_os = \"android\"target_cpu = \"arm\" # (default)is_debug = true # (default) 빌드 dependencies 설정 12#빌드에 필요한 시스템 패키지 업데이트~/chromium$ src/build/install-build-deps-android.sh OpenJDK 설정 업데이트-&gt; 없으면 설치법은 (https://www.davidlab.net/ko/tech/how-to-setup-android-dev-env-on-ubuntu-part1/) 123456sudo update-alternatives --config javacsudo update-alternatives --config javasudo update-alternatives --config javawssudo update-alternatives --config javapsudo update-alternatives --config jarsudo update-alternatives --config jarsigner 하위 디렉토리 동기화 1~/chromium/src$ gclient sync APK 빌드&amp; 설치 1~/chromium/src$ . build/android/envsetup.sh device 연결 됬는지 확인! 1third_party/android_tools/sdk/platform-tools/adb devices 빌드를 full browser, Content shell, Webview shell 버전 각각 다르게 할 수 있다. Full browser 빌드 12~/chromium/src$ ninja -C out/Release chrome_public_apk~/chromium/src$ build/android/adb_install_apk.py out/Release/apks/ChromePublic.apk # For gyp 다른 버전들 빌드 방법은 위에 있는 크로미움 사이트에서 확인가능! 설치12~/chromium/src$ build/android/adb_install_apk.py out/Release/apks/ChromePublic.apk # For gyp.~/chromium/src$ CHROMIUM_OUTPUT_DIR=$gndir build/android/adb_install_apk.py $gndir/apks/ChromePublic.apk # For gn","categories":[{"name":"chromium","slug":"chromium","permalink":"https://youngi08.github.io/categories/chromium/"}],"tags":[{"name":"android","slug":"android","permalink":"https://youngi08.github.io/tags/android/"},{"name":"chromium","slug":"chromium","permalink":"https://youngi08.github.io/tags/chromium/"}]},{"title":"알고리즘 | 선택정렬","slug":"selection-sort","date":"2017-08-31T06:08:32.000Z","updated":"2017-08-31T07:10:53.000Z","comments":true,"path":"2017/08/31/selection-sort/","link":"","permalink":"https://youngi08.github.io/2017/08/31/selection-sort/","excerpt":"","text":"선택 정렬(Selection Sort) 정렬 되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환해나가는 방식 선택 정렬의 비교 횟수= (n-1) + (n-2) + (n-3) + … + 1= n(n-1)/2 시간 복잡도 평균, 최악, 최고: O(n^2) 기존의 레코드들이 정렬이 되어 있던, 되어 있지 않던 상관 없이 레코드들의 가장 처음부터 끝까지 비교하는 과정이 모두 같기 때문 동작원리 배열의 첫원소를 key값으로 설정하고 나머지 배열 원소 중 가장 작은 원소를 찾아 교체한다. 교체후에 첫 원소를 제외한 두번째 원소를 키 값으로 설정하고 1단계를 반복한다. 나머지 리스트를 모두 정렬이 될 때까지 1, 2 단계를 반복하여 정렬을 완료한다. 예제코드 1234567891011121314151617void selectionSort()&#123; intDataSet[]=&#123;6,4,2,3,1,5&#125;; int i, j, indexMin, temp; for(i =0; i &lt; n-1; i++)&#123; indexMin=i; for(j = i+1; j &lt; n; j++)&#123; if(list[j] &lt; DataSet[indexMin])&#123; indexMin = j; &#125; &#125; temp=DataSet[indexMin]; DataSet[indexMin]=DataSet[i]; DataSet[i]=temp; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/tags/algorithm/"}]},{"title":"알고리즘 | 삽입정렬","slug":"insert-sort","date":"2017-08-31T05:41:31.000Z","updated":"2017-08-31T07:10:56.000Z","comments":true,"path":"2017/08/31/insert-sort/","link":"","permalink":"https://youngi08.github.io/2017/08/31/insert-sort/","excerpt":"","text":"삽입정렬(Insert Sort) 데이터 집합을 순회하면서 정렬이 필요한 요소를 뽑아내어 이를 다시 적당한 곳에 삽입해 나가는 알고리즘 아직 정렬 되지 않은 임의의 데이터를 이미 정렬 된 부분의 적절한 위치에 삽입해가며 정렬하는 방식 시간 복잡도 최선 list가 이미 정렬 되어 있는 경우에는 외부 루프 n-1번만 실행되고 각 단계에서 데이터의 이동 없이 1번의 비교 연산만 수행 삽입 정렬은 비교적 정렬이 된 리스트에서는 이동 횟수가 선택 정렬과 버블 정렬에 비해 적게 일어난다는 장점 O(n) 최악 오름차순으로 정렬해야 하는 데이터가 역순으로 내림차순으로 정렬 되어 있다면 각 단계에서 앞에 놓인 데이터들은 전부 한 칸씩 뒤로 이동 해야하고, 외부 루프 안의 각 반복마다 i번 비교가 수행 따라서 데이터의 수가 많고 크기가 큰 경우에는 적합하지 않음 O(n^2) 동작원리 key 값을 기준으로 key의 앞은 정렬이 된 상태이다. i번째 요소를 정렬을 하기 위해서 i번째 배열의 값을 key로 저장을 한다. key값을 기준으로 i-1부터 검사를 하며 key 값보다 값이 클 경우 값을 한 칸씩 오른쪽으로 이동 시킨다. key 값보다 작거나 같은 값이 나올 때까지 2번 과정을 반복한다. 3번 과정에서 key값이 들어갈 위치를 찾으면 key값을 위치에 삽입한다. i+1 번째 배열의 값을 key로 저장 하며 모든 레코드가 정렬될 때 까지 1번 과정부터 반복 예제코드 1234567891011void insertSort()&#123; intDataSet[]=&#123;6,4,2,3,1,5&#125;; for(inti=1; i&lt;n; i++)&#123; key=DataSet[i]; //두 번째 값부터 선택 for(intj=i-1; j&gt;=0&amp;&amp;list[j]&gt;key; j—-)//선택된 값(key)보다 작은 값을 찾는다 DataSet[j+1]=DataSet[j];// 작은 값을 찾은 경우 그 값뒤의 모든 값을 우측으로 이동 DataSet[j+1]=key;//해당되는 곳에 값을 삽입 &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/tags/algorithm/"}]},{"title":"알고리즘 | 버블정렬","slug":"bubbule-sort","date":"2017-08-31T04:01:03.000Z","updated":"2017-08-31T07:10:58.000Z","comments":true,"path":"2017/08/31/bubbule-sort/","link":"","permalink":"https://youngi08.github.io/2017/08/31/bubbule-sort/","excerpt":"","text":"버블정렬(Bubble Sort) 데이터 집합을 순회하면서 집합 내의 이웃 요소들끼리의 교환을 통해 정렬을 수행 제일 큰 원소를 오른쪽으로 옮기는 방법 버블 정렬의 비교 횟수= (n-1)+(n-2)+…+(n-(n-2))+(n-(n-1))= (n-1)+(n-2)+…+3+2+1 = (n-1)(n/2)비교횟수 T(n)= (n(n-1))/2 시간복잡도 평균, 최악, 최고: O(n^2) 기존의 레코드들이 정렬이 되어 있던, 되어 있지 않던 상관 없이 레코드들의 가장 처음부터 끝까지 비교하는 과정이 모두 같기 때문 개선 방안 -&gt; 정렬되어있는 경우 루프를 취소하고 빠져나오도록 하는 방법 공간복잡도: O(1) 동작원리 이웃 하는 두 레코드를 비교하여 큰 레코드는 우측으로 밀어낸다. 더 이상 이웃 하는 레코드가 없을 때까지 반복한다. 리스트의 가장 우측부터 큰 레코드로 정렬이 된다. 모든 레코드가 정렬이 될 때까지 반복한다. 예제코드 12345678910111213141516void BubbleSort()&#123; int DataSet[]=&#123;6,4,2,3,1,5&#125;; int Length =sizeof(DataSet)/sizeof(DataSet[0]); for(int i=0; i&lt;Length-1; i++)&#123; for(int j=0; j&lt;Length-(i+1); j++)&#123; if(DataSet[j]&gt; DataSet[j+1])&#123; //인접한 두 값을 비교 //정렬되지 않은 두 값 temp = DataSet[j+1]; DataSet[j+1]=DataSet[j]; DataSet[j]=temp; &#125; &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/tags/algorithm/"}]},{"title":"알고리즘 | start","slug":"algorithm-start","date":"2017-08-31T03:53:59.000Z","updated":"2017-08-31T07:10:59.000Z","comments":true,"path":"2017/08/31/algorithm-start/","link":"","permalink":"https://youngi08.github.io/2017/08/31/algorithm-start/","excerpt":"","text":"Categories 알고리즘 | 개념 자료구조의 분류 선형구조: 선형리스트(배열), 연결 리스트, 스택, 큐, 데크 비선형 구조: 트리, 그래프 정렬(Sorting) 알고리즘 | 정렬 시간복잡도 내부 정렬 소량의 데이터를 주기억장치에만 기억시켜서 정렬하는 방식 알고리즘 | 버블정렬 알고리즘 | 삽입정렬 알고리즘 | 선택정렬 알고리즘 | 퀵정렬 알고리즘 | 합병정렬 알고리즘 | 2-Way 합병 정렬 외부 정렬 대량의 데이터를 보조기억장치에 기억시켜서 정렬하는 방식 대부분 합병정렬(Merge Sort) 기법으로 처리","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/tags/algorithm/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-30T17:55:34.000Z","updated":"2017-08-31T02:22:19.000Z","comments":true,"path":"2017/08/31/hello-world/","link":"","permalink":"https://youngi08.github.io/2017/08/31/hello-world/","excerpt":"","text":"기존 블로그와 에버노트에서 이전중~http://kisys.tistory.com/","categories":[],"tags":[]},{"title":"odroid에 구글 크로미움 포팅하기","slug":"porting-chromium-to-odroid","date":"2017-08-30T09:41:31.000Z","updated":"2017-08-31T07:20:14.000Z","comments":true,"path":"2017/08/30/porting-chromium-to-odroid/","link":"","permalink":"https://youngi08.github.io/2017/08/30/porting-chromium-to-odroid/","excerpt":"","text":"삽질한 것에 비해 굉장히 간단한 방법으로 할 수 있다. 여기에 몇 일을 날렸는가…ㅠㅠ먼저 원리를 제대로 이해하고 했으면 삽질이라고 할 수도 없을 만큼 빠른 시간 안에 할 수 있었을 것이다. 방향을 이상하게 잡아서 삽질하다 보니 굉장히 오래 걸리게 되었다. odroid xu3 보드에 크로미움을 포팅하기 위해서는 arm 32bit용으로 컴파일 해야 한다. Hardkernel 사이트에서 크로스컴파일을 위한 툴체인, 환경을 세팅한다. 내 보드는 xu3이다.http://odroid.com/dokuwiki/doku.php?id=en:xu3_building_kernel 크로미움 크로스컴파일 하기http://unix.stackexchange.com/questions/176794/how-do-i-cross-compile-chromium-for-arm위 사이트 참조! 크로미움 코드를 다운로드 하기 위한 과정은 같다.(1) depot_tools 설치12$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools$ export PATH=$PATH:~/chromium/depot_tools (2) 크로미움 코드 다운로드12$ mkdir chromium &amp;&amp; cd ~/chromium$ fetch --nohooks chromium (3)ARM용 컴파일https://www.olimex.com/forum/index.php?topic=4109.01234./build/install-build-deps.sh --arm &amp;&amp;gclient sync &amp;&amp;GYP_CROSSCOMPILE=1 GYP_DEFINES=\"target_arch=arm arm_float_abi=hard component=shared_library linux_use_gold_flags=1\" gclient runhooks &amp;&amp;ninja -C out/Release chrome","categories":[{"name":"odroid","slug":"odroid","permalink":"https://youngi08.github.io/categories/odroid/"}],"tags":[{"name":"chromium","slug":"chromium","permalink":"https://youngi08.github.io/tags/chromium/"},{"name":"odroid","slug":"odroid","permalink":"https://youngi08.github.io/tags/odroid/"}]}]}