{"meta":{"title":"Hello","subtitle":"youngi's IT Blog","description":null,"author":"Inyoung Park","url":"https://youngi08.github.io"},"pages":[],"posts":[{"title":"Web | Server-Side 처리 과정","slug":"web-server-side","date":"2017-11-24T08:46:13.000Z","updated":"2017-11-24T09:30:18.049Z","comments":true,"path":"2017/11/24/web-server-side/","link":"","permalink":"https://youngi08.github.io/2017/11/24/web-server-side/","excerpt":"","text":"웹 서버 인터넷 웹브라우저의 요청이 들어오면 그에 해당하는 웹페이지를 찾아서 보내주는 일을 하는 컴퓨터를 지칭한다. 정확히 표현하면 인터넷 사용자의 URL요청을 받아서 그에 해당하는 웹페이지(HTML문서나 이미지)를 찾아서 다시 웹브라우저로 보내주는 것이다. 웹어플리케이션 서버(WAS) 웹어플리케이션 서버는 웹서버에 웹어플리케이션을 합친 것이다. 우리가 웹페이지를 볼때 화면이 동적일 때가 있을 것이다. 동적이란 말은 이를테면 특정 URL을 요청했을 때 뉴스페이지 같은 곳에서는 각각의 기사에 대하여 다른 기사제목과 내용들이 표시 되는일들을 말하는데 정적인 웹 서버로는 이것을 처리가 불가능하다. 웹 서버가 웹어플리케이션 프로그램을 호출해야 가능한 일이다. JSP같은 기술이 웹어플리케이션의 역할을 담당한다. 12웹 서버 : 정적인 처리 담당 html, 이미지등 ex) Apache웹 어플리케이션 서버(WAS) : jsp, 서블릿 담당(동적처리) ex) Tomcat JSP(Java Server Pages) JSP 는 자바 Servlet 기술을 확장시켜 웹 환경 상에서 자바만으로 서버 사이드 모듈을 개발하기 위한 기술이다. JAVA기반으로 만들어서 JAVA의 모든 기능을 사용할 수 있어 발전 가능성이 무한하다. ASP, PHP 처럼 HTML 태그 사이 사이에 동적인 contents 생성 을 담당할 JAVA 코드가 들어 있는 형태로 Servlet 의 형태와 다른 모습을 취하고 있다. 커스텀 태그를 만들어 사용할 수 있으며, JSTL(JSP Standard Tag Library)과 같은 태그 라이브러리를 이용할 수 있어 개발이 용이하다. 서블릿으로 컴파일된 후 메모리에서 처리되기 때문에 많은 사용자의 접속도 원활하게 처리할 수 있디. Java Beans를 이용해 JSP 또는 다른 서블릿 간의 데이터를 쉽게 공유 할 수 있다. Servlat(Server + Applet) JAVA를 이용한 서버 프로그래밍 기술이다. JAVA 언어를 기반으로 동적인 contents 를 생성하는 기술로 JAVA 프로그램을 작성하는 형식과 거의 같다. JAVA 코드 안에 HTML 태그가 섞여 있어 작업에 대한 분리적인 측면으로 볼 때 효율성이 떨어진다. 프로그래머가 프로그래밍하기 어려우며 수정하기 어려운 단점이 있다. JSP와 서블릿 차이 JSP는 HTML과 같은 일반적인 텍스트 파일 구조 서블릿은 자바 소스로 작성된 클래스 파일 구조 JSP는 서블릿 컨테이너에 의해 서블릿 형태의 자바 소스로 변환되어 클래스로 컴파일 됨 서블릿 컨테이너 서블릿 컨테이너는 서블릿을 실행하고 JSP를 서블릿 코드로 변환하는 기능을 수행 변환된 JSP의 서블릿 클래스를 실행하고 웹 서버의 메모리에 적재하고 사용자 요청에 따라 실행예: Tomcat, WebLogic, JBoss, Jetty 등 HTTP 서버 URL 주소를 해석 하는 역활 HTTP 서버는 단순히 어떤 주소(URL) 요청이 들어왔을 경우 그 주소에 미리 매핑되어 있는 콘텐츠(HTML 파일이나 이미지 등)를 사용자의 브라우저에 응답 형태로 전송하는 역할을 한다. 이 때 만일 요청된 URL이 서블릿 클래스 또는 JSP파일(ex. http://www.sevlet.com/servlet 또는 http://www.servlet.com/home.jsp)일 경우 HTTP 서버는 이를 웹 컨테이너에서 처리하도록 클라이언트의 요청을 넘겨준다. 웹 컨테이너(Web Container) 서블릿 클래스 또는 JSP 파일의 실행 요청을 처리해주역할 웹 컨테이너에서는 요청된 URL에 맞는(미리 설정된) 서블릿 클래스 또는 JSP 파일을 실행하여 그 결과를 HTTP 서버에 넘겨주게 되고 이는 응답 메시지의 형태로 사용자의 브라우저에 전송된다. JSP 처리과정 사용자가 브라우저 주소창에 도메인을 입력하면 브라우저는 그 도메인에 해당하는 IP 주소를 찾기 위해서 DNS 서버에 접속한다. DNS 서버는 도메인에 대한 IP 주소를 알려준다. IP 주소를 획득한 브라우저는 인터넷에 접속해서 IP 주소에 있는 서버에 HTTP 프로토콜로 요청한다. 웹 서버가 요청 내용을 분석하고 서블릿 컨테이너에 요청을 넘겨 처리한다4-1. HTML인 경우와 JSP인 경우 구분하여 처리한다.4-2. HTML인 경우 HTML, CSS 등등 추가적인 행위가 필요없는 정적인 파일을 찾아서 사용자에게 전달한다.4-3. JSP인 경우 웹 서버의 서블릿 컨테이너를 이용한 처리 과정이 필요하다.[서블릿 컨테이너를 이용한 처리 과정] 찾은 파일을 서블릿으로 파싱한다.(hello.jsp -&gt; helloServlat.java) 만약 이미 변환 되어있는 파일이 있다면 그 파일을 바로 실행한다. (helloServlat.class) 이전에 요청했던 페이지일 경우 파싱할 필요 없이 파싱했던 클래스파일을 메모리에 적재한다. 서블릿 파일을 실행가능한 class파일로 컴파일 한다. (helloServlat.java -&gt; helloServlat.class) 클래스 파일은 메모리에 적재가 되어 실행된다. 컴파일된 .class는 컴퓨터에서 실행할 수 있는 형태로 특정한 기능을 수행할 수 있게 된다. 이후 소스 변경 전까지 해당 파일은 메모리에 상주하면서 다시 컴파일 되지 않고 서비스된다. 데이터베이스 처리 혹은 별도의 기능을 위한 클래스 호출 등이 있다면 실행하고 결과를 취합한다. (Java Beans) 웹서버는 취합한 결과를 기반으로 브라우저가 인식할수 있는 정적페이지(HTML)를 구성하여 웹 브라우저에 전송한다.","categories":[{"name":"web","slug":"web","permalink":"https://youngi08.github.io/categories/web/"},{"name":"server","slug":"web/server","permalink":"https://youngi08.github.io/categories/web/server/"}],"tags":[]},{"title":"보안 | 사용자 인증","slug":"9-user-certification","date":"2017-09-04T05:57:08.000Z","updated":"2017-09-04T08:37:53.000Z","comments":true,"path":"2017/09/04/9-user-certification/","link":"","permalink":"https://youngi08.github.io/2017/09/04/9-user-certification/","excerpt":"","text":"인증 메시지 인증 전달되는 메시지의 이상 유무를 확인할 수 있는 기능(무결성 검증) 전송 중 발생할 수 있는 메시지 내용 변경, 메시지 순서 변경, 메시지 삭제 여부를 확인하는 기능 사용자 인증 정당한 가입자의 접속인가를 확인하기 위한 사용자 인증이 컴퓨터 통신망 운영에 필수적 요건 사용자 인증의 유형 type3과 type4를 묶어 type3 생체인증이라 하기도 한다 유형 설명 예 type1(지식) 주체는 그가 알고 있는 것을 보여줌 패스워드, 핀(PIN) type2(소유) 주체는 그가 가지고 있는 것을 보여줌 토큰, 스마트 카드 type3(존재) 주체는 그를 나타내는 것을 보여줌 생체인증 type4(행위) 주체는 그가 하는 것을 보여줌 서명, 움직임, 음성 Two Factor 위 타입 중에서 두 가지 인증 메커니즘을 결함하여 구현 토큰 + PIN Multi Factor 가장 강한 인증으로 세 가지 이상의 인증 메커니즘 사용 토큰 + PIN + 지문인식 사용자 인증 기법 지식 기반 인증(What you know) 사용자가 알고 있는 어떤 것에 의존하는 인증기법 사용자는 신원을 입증하기 위한 신원정보 제공 사용자에 의해 제공된 지식요인은 사용자 신분확인을 통하여 획든한 참조지식과 비교 -&gt; 일대일 검증 보안성은 비밀번호의 크기와 랜덤성에 달려 있음 패스워드 사용자가 시스템의 자원을 활용하기 위해 시스템에 접속하고자 할 때 사용 됨(로그인)","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 접근통제 개요","slug":"8-access-control-overview","date":"2017-09-04T05:29:25.000Z","updated":"2017-09-04T05:58:41.000Z","comments":true,"path":"2017/09/04/8-access-control-overview/","link":"","permalink":"https://youngi08.github.io/2017/09/04/8-access-control-overview/","excerpt":"","text":"접근통제 개요 접근통제 기본 개념 주체 로 불리는 외부에서 접근하는 사람, 시스템 등이 접근 대상이 되는 객체 라고 불리는 시스템에 접근할 때 보안상의 위협, 변조 등과 같은 위험으로부터 객제와 제반 환경을 보호하기 위한 보안대책 접근제어 적절하지 못한 접근을 차단하기 위한 방법과 규칙의 집합체 접근통제 절차 식별 본인이 누구라는 것을 시스템에 밝히는 것 사용자명, 계정번호, 메모리 카드 인증 주체의 신원을 검증하기 위한 사용 증명 활동 패스워드, PIN, 토큰 인가 인증된 주체에게 접근을 허용하고 특정 업무를 수행할 권리를 부여하는 과정 접근제어목록(ACL), 보안등급 책임추적성 단계 책임추적성은 시스템에 접근한 주체가 시스템에 어떤 행위를 하고 있는지 기록 문제발생 시 원인 및 책임 소재를 파악하기 위한 목적으로 개발 접근통제 기본 원칙 직무분리 업무의 발생부터 승인, 수정, 확인, 완료 등이 처음부터 끝까지 한 사람에 의해 처리될 수 없게 하는 보안 정책 보안/감사, 개발/운영, 암호키 관리/암호키 변경 최소 권한 허가받은 일을 수행하기 위한 최소한의 권한만을 부여하며, 권한남용으로 인한 피해를 최소화 Need-to-Know(알 필요성)와 같은 의미 (주체에게 필요한 정보 여부) 정보등급 분류, 접근통제 리스트","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 키, 난수","slug":"7-key-and-random-number","date":"2017-09-04T05:01:16.000Z","updated":"2017-09-04T05:18:38.000Z","comments":true,"path":"2017/09/04/7-key-and-random-number/","link":"","permalink":"https://youngi08.github.io/2017/09/04/7-key-and-random-number/","excerpt":"","text":"키 키 암호기술을 사용하기 위해서는 반드시 키(key)라 불리는 대단히 큰 수가 필요 키 공간(Key-Space)의 크기, 즉 가능한 키의 총 수는 크면 클수록 무차별 공격에 강하다 다양한 키 URL이 https:// 로 시작되는 페이지에 접속하면 웹 서버와 브라우저 사이에서만 SSL/TLS에 의해 암호화된 통신이 수행 됨 세선키 : 통신 때마다 한번만 사용되는 키 마스터 키: 반복적으로 사용되는 키 CEK와 KEK CEK(Contents Encrypting Key) 사용자가 직접 이용하는 정보(콘텐츠)가 암호화의 대상이 되고 이때 사용하는 키 KEK(Key Encrypting Key) 키를 암호화하는 키 패스워드를 기초로 한 암호(PBE) 솔트 의사난수 생성기로 만들어지는 랜덤한 수 키(KEK)를 만들 떄에 패스워드와 함께 일방향 해시함수에 입력 됨 사전 공격을 막기 위해 존재 난수 난수의 용도 키의 생성, 키쌍의 생성, 초기화 벡터의 생성, 비표의 생성, 솔트이 생성, 일회용 패드 난수의 성질 무작위성, 예측 불가능성, 재현 불가능성 의사난수 생성기 하드웨어난수 생성기(RNG, random number generator) 열이나 음의 변화처럼 예측이나 재현이 사실상 불가능한 자연 현상을 센서로 감지해서 그 결과를 기초로 난수열 생성 의사난수 생성기(PRNG, pseudo random number generator) -&gt; 소프트웨어 소프트웨어만으로는 진정한 난수를 생성 할 수없기 때문에 “의사” 난수 생성기라 부른다 내부상태(의사난수 생성기가 관리하고 있는 메모리 값)를 가리면 외부에서 주어진 종자(seed)를 기초로 의사난수열 생성","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | PKI","slug":"6-2-PKI","date":"2017-09-04T01:36:33.000Z","updated":"2017-09-04T02:10:38.000Z","comments":true,"path":"2017/09/04/6-2-PKI/","link":"","permalink":"https://youngi08.github.io/2017/09/04/6-2-PKI/","excerpt":"","text":"PKI PKI(Public-Key Infrastructure) 공개키 알고리즘을 위한 키 관리 구조 제공 서비스 기밀성, 접근제어, 무결성, 인증, 부인방지 구성요소 인증기관(CA, Certification Authority) 인증정책을 수립하고, 인증서 및 인증서 효력정지 및 폐기목록을 관리하며, 다른 CA와의 상호 인증 제공 정책 승인기관(PPA, Policy Approving Authority) 공개키 기반 구조 전반에 사용되는 정책과 절차 생성 수립 하위 기과들의 정책 준수 상태 및 적정성 감사 정책 인증기관(PCA, Policy Certification Authority) PAA 아래 계층으로 자신의 도메인 내의 사용자와 인증기관이 따라야 할 정책 수립 인증기관의 공개키를 인증하고 인증서, 인증서 폐지 목록 등 관리 등록기관 인증기관과 멀리 떨어져 있는 사용자들을 위해 인증기관과 사용자 사이에 등록기관을 두어 인증기관 대신 사용자들의 인증서 신청 시 그들의 신분과 소속을 확인하는 기능 수행 저장소 사용자의 인증서를 저장하는 저장소의 역할을 하는 일종의 데이터베이스 사용자 PKI 내의 사용자는 사람뿐만 아니라 사람이 이용하는 시스템 모두 의미 PKI의 형태 계층구조 네트워크 구조 혼합형 구조 PKI의 주요 관리 대상 인증서(PKC, Public-Key Certiticate) 한 쌍의 공개키/개인키와 특정 사람/기관을 연결시켜 주는 것을 보증해줌 공개키 인증서에는 이름, 소속, 메일 주소 등의 개인정보 및 그 사람의 공개키가 기재되고, 인증기관의 개인키로 전자서명 되어있음 인증서 표준 규격 X.509 인증서의 작성, 교환을 수행할 때의 표준 규격 X.509 인증서 폐지 목록 프로파일 CRL(Certification Revocation List) 폐지된 인증서들에 대한 목록 인증서 폐지 사유 사용자 개인키가 노출되었거나 훼손된 것으로 여겨진다 CA가 사용자를 더 이상 인증해줄 수 없다 CA의 인증서가 노출되었거나 훼손된 것으로 여겨진다 인증서 운영 프로토콜 온라인 인증서 상태 검증 프로토콜(OCSP, Online Certiticate Status Protocol) 실시간으로 인증서의 상태 정보를 확인할 수 있는 효율적인 방법 구성 요소 OCSP 클라이언트, OCSP 서버, 인증 서버로 구성 서버 기반 인증서 검증 프로토콜(SCVP, Simple Certitication Validation Protocol) SCVP 서버를 이용하여 클라이언트의 인증서 처리에 대한 부담을 줄여 줌 SCVP 서버는 인증서의 유효성 혹은 신뢰할 수 있는 인증서의 체인 등 인증서에 관한 가치 있는 다양한 정보 제공","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 해시함수와 응용","slug":"5-hash-functions-and-applications","date":"2017-09-03T12:02:00.000Z","updated":"2017-09-03T14:06:09.000Z","comments":true,"path":"2017/09/03/5-hash-functions-and-applications/","link":"","permalink":"https://youngi08.github.io/2017/09/03/5-hash-functions-and-applications/","excerpt":"","text":"일방향 해시함수 일방향 해시함수 해시함수는 임의의 길이를 갖는 메시지를 입력으로 하여 고정된 길이의 해시 값 또는 해시 코드라 불리는 값을 출력하는 함수 해시함수 h는 임의의 길이의 문자열을 고정된 길이를 갖는 n비트 문자열로 대응 h: D(정의역) -&gt; R(치역) 다대일 대응 함수 (충돌이 반드시 존재함 의미) 특징 고정길이의 해시값 계산 해시값 고속 계산 일방향성 메시지에 따라 해시값 달라짐 충돌(collision) : 2개의 다른 메시지가 같은 해시값을 갖는 것 일방향 해시함수를 무결성 확인에 사용하기 위해서는 충돌이 발견되어서는 안됨 해시함수의 보안 요구사항 해시 값 h = H(x) : x는 함수 H를 사용한 해시함수 결과가 h인 데이터 블록 프리이미지(입력되는 이미지) 저항성(역상 저항성) 어떠한 코드 h에 대해서도 H(x)=h인 x를 찾는 것은 계산적으로 실행 불가능 제2프리이미지 저항성(두 번째 역상 저항성, 약한 충돌 내성) 메시지를 쉽게 위조할 수 없도록 하는 성질 어떠한 블록 x에 대해서도, H(y)=h(x)인 y=/x인 것을 찾는 것이 계산적으로 실행 불가능 충돌 저항성(강한 충돌 내성) 동일한 다이제스트를 가지는 2개의 메시지를 구하지 못하도록 하는 것 H(x)=h(y)인 어떤(x,y)짝을 찾는 것이 계산적으로 실행 불가능 키가 없는 해시함수 전용함수(새로 만드는 해시함수) 메시지 다이제스트(Message Digest)(MD2 -&gt; MD4 -&gt; MD5) MD5는 메시지를 512비트로 된 블록들로 나누고 128비트 다이제스트 출력 128비트 메시지 다이제스트는 충돌 공격에 내성을 갖기에 길이가 너무 짧다고 알려짐 SHA(Secure Hash Algorithm) MD4 모델 기반, MD5보다 조금 느리지만 좀더 안전 블록암호 기반 해시함수 반복 암호학적 해시함수 안에 사용되는 압축함수 자리에 대칭피 블록암호 사용 새로운 압축함수 생성 필요 없이 DES나 AES처럼 검증된 여러 개의 대칭키 알고리즘을 일방향 함수로 사용 가능 모듈 연산에 기반을 둔 해시함수 압축 함수의 기반을 모듈 연산의 반복적인 수행에 두고 있는 해시함수 장점 : 하드웨어나 소프트웨어 자체에 내장된 모듈 연산 사용 가능 단점 : 속도가 빠르지 않고 안전성 연구에 대한 역사가 짧음 키를 사용하는 해시함수 메시지 인증 기능을 가진 함수 함수 자체의 안정성과 키의 비밀성에 안전성 둠 블록 암호에 기반을 둔 메시지 인증 알고리즘 CBC(Cipher Block Chaining) 모드 이용 메시지 인증코드(MAC) 메시지 인증코드(MAC) 무결성을 확인하고 메시지에 대한 인증을 하는 기술 임의 길이의 메시지와 송신자 및 수신자가 공유하는 키라는 2개의 입력을 기초로 해서 고정 비트길이의 출력(MAC 값)을 계산하는 함수 블록 암호나 해시 함수에 기반을 두기 때문에 전자 서명보다 훨씬 빠름 MAC의 키 배송 문제 MAC에서는 송신자와 수신자가 키를 공유할 필요가 있다 송신자와 수신자가 키를 공유할 필요가 있다는 것은 대칭키 암호 때의 키 배송 문제와 같은 문제가 메시지 인증코드에서도 일어남을 의미 변경 감지 코드(MDC, Modification Detection Code) 메시지의 무결성을 보장하는 메시지 다이제스트","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 전자서명","slug":"6-1-digital-signatures","date":"2017-09-03T11:44:40.000Z","updated":"2017-09-04T01:36:01.000Z","comments":true,"path":"2017/09/03/6-1-digital-signatures/","link":"","permalink":"https://youngi08.github.io/2017/09/03/6-1-digital-signatures/","excerpt":"","text":"전자서명 전자서명의 형식 공개키 암호방식을 이용한 공개키 서명방식 관용 암호방식을 이용한 중재서명방식 전자서명 과정 송신자는 서명 알고리즘을 이용해서 메시지에 서명을 한다 수신자는 메시지와 서명을 받고 이들에 검증 알고리즘을 적용한다 전자서명의 주요 기능 위조 불가 서명자 인증 부인방지 변경 불가 재사용 불가 전자서명 구조 RSA 전자서명 구조 메시지에 서명을 하고 검증 할 수 있음 ElGamal 전자서명 구조 이산대수 문제를 이용한 최초의 서명 방식 Schnorr 전자서명 구조 서명의 크기를 줄이기 위해 Elgmal 기반으로 새로운 구조 제안 전자서명 표준 미국의 전자서명 표준 ElGamal 전자 서명 개방 방식으로 서명과 검증에 소요되는 계산량 획기적으로 줄인 방식 전자서명 방식 메시지 복원형 전자서명 서명자가 자신의 개인키를 이용하여 메시지를 암호화하여 전송하면 검증자가 서명자의 공개키를 이용하여 서명된 암호문 복호화 기존의 공개키 암호방식을 이용 부가형 전자 서명 임의의 길이로 주어진 메시지를 해시 알고리즘을 이용하여 일정한 길이로 압축하고, 해시한 결과에 서명자의 개인키를 이용하여 전자서명하고 메시지에 덧붙여 전송 메시지 전체를 암호화하는 대신에 일방향 해시함수를 사용하여 메시지의 해시값을 구하고, 그 해시값을 암호화(해시값에 서명)하도록 함 특수 전자서명 부인방지 전자서명 자체 인증 방식을 배제시켜 서명을 검증할 때 반드시 서명자의 도움이 있어야 검증 가능 의뢰 부인방지 서명 수신자 지정 서명 지정된 수신자만이 서명을 학인할 수 있고 필요시 제3자에게 그 서명이 서명자에 의해 자신에게 발행된 서명임을 증명할 수 있게 함 은닉 서명(블라인드 서명) 서명문의 내용을 숨기는 서명 방식으로 제공자의 신원과 서명문을 연결시킬 수 없는 익명성 유지 위임 서명 서명자를 대신해서 대리로 서명할 수 있도록 구성한 서명 방식 다중 서명 동일한 전자문서에 여러 사람이 서명하는 것 전자 봉투 전달하고자 하는 메시지를 암호화하여 한 사람을 통해서 보내고, 암호화키는 다른 사람에게 가져가게 하는 것 전자서명의 응용 보안 공지 소프트웨어의 다운로드 공개키 인증서 전자투표 전자투표 시스템 구현을 위한 요구사항 완정성, 비밀성, 재사용 불가, 공정성, 적임성, 검증성, 강건성 전자투표 방식 투표소 전자투표(PSEV, Poll Site E-Voting) 투표소에 선거 관리자가 없고 기기에 전자 인증 장치를 설치해 관리 부분을 해결 원격 인터넷 투표(REV, Remote Internet E-Voting) 기술적 위험이 높고 관리인 없이 자유롭게 투표하므로 비밀투표 침해가능성 있음 전자입찰 시스템 요구사항 독립성, 비밀성, 무결성, 공평성, 안전성 문제점 네트워크상의 메시지 유출 입찰자와 서버 사이의 공모 입찰자간의 공모 입찰자와 입찰 공무자간의 공모","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 대칭키 암호","slug":"3-symmetric-key","date":"2017-09-03T11:18:03.000Z","updated":"2017-09-03T12:05:58.000Z","comments":true,"path":"2017/09/03/3-symmetric-key/","link":"","permalink":"https://youngi08.github.io/2017/09/03/3-symmetric-key/","excerpt":"","text":"대칭키 암호 현대 블록 암호의 구성요소 확산 평문의 통계적 성질을 암호문 전반에 퍼뜨려 숨김(암호문과 평문사이의 관계를 숨김) 혼돈 암호문과 키의 상관관계를 숨김-&gt; 만족시키기 위해 전치요소(P-박스), 치환요소(S-박스) 설계 P-박스 전치 암호 병렬적 수행 단순(straight) 확장(expansion) n비트를 입력받아 m비트를 출력하는 P-박스로서 n&gt;m을 만족한다 축소(compression) n비트를 입력받아 m비트를 출력하는 P-박스로서 n&lt;m을 만족한다 역함수의 존재성 단순 P-박스는 역함수가 존재한다 축소 P-박스와 확장 P-박스는 역함수가 존재하지 않는다 S-박스 치환 암호의 축소 모형, 입/출력 개수 달라도 됨 swap, shift, combine 합성 암호 shamon 확률을 기초로 한 정보이론의 창시자 일회용 패드의 안정성 증명 혼돈, 확산 정의 라운드 반복적으로 사용되는 합성(S,P 박스 / 확산, 혼돈) 암호 Feistel 암호 DES를 포함한 대칭 블록 암호 알고리즘의 기반이 되는 구조 SPN 구조 입력을 여러 개의 소블록으로 나누고 각 소블록을 S-box로 입력하여 대치시키고 S-box의 출력을 P-box로 전치하는 과정을 반복하는 방식 DES(Data Encryption Standard)","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 암호학 개요","slug":"2-cryptography-overview","date":"2017-09-03T08:13:01.000Z","updated":"2017-09-03T12:55:18.000Z","comments":true,"path":"2017/09/03/2-cryptography-overview/","link":"","permalink":"https://youngi08.github.io/2017/09/03/2-cryptography-overview/","excerpt":"","text":"암호학의 개본 개념 암호약속된 당사자 또는 집단에서만 암호문에 내포된 내용을 알 수 있게 하는 일종의 문서 암호학평문을 다른 사람이 알아볼 수 없는 암호문으로 만들고 특정한 비밀키를 알고 있는 사람만이 다시 평문으로 복원시킬 수 있도록 하는 암호 기술과 이를 제3자(도청자)가 해독하는 방법을 분석하는 암호해독에 관하여 연구하는 학문 암호에서 사용하는 이름 앨리스와 밥(Alice and Bob) - 송신자와 수신자 이브(Eve) - 도청자, 소극적 공격자 -&gt; 암호문 스틸 맬로리(Mallory) - 악의를 가진 공격자(재전송) 트렌트(Trent) - 신뢰할 수 있는 중재자, 중립적 위치에 있는 제3자 빅터(Victor) - 의도된 거래나 통신이 실제로 발생했음을 검증할 때 등장 암호화와 복호화 평문 - 암호화하기 전의 메시지 암호문 - 암호화 한 후의 메시지 앨리스와 밥은 암호라는 기술을 사용해서 메일의 기밀성(비밀성) 을 유지 암호화 C = Ek (P) : 평문 P를 키 K로 암호화하여(E) 암호문 C를 얻는다 복호화 P = Dk (C) : 암호문 C를 키 K로 복호화하여(D) 평문 P를 얻는다 암호 기법의 분류 치환암호 비트, 문자 또는 문자의 블록을 다른 비트, 문자 또는 블록으로 대체 평문의 문자를다른 문자로 교환하는 규칙 전치암호 비트, 문자 또는 블록이 원래의 의미를 감추도록 재배열 문자 집합 내부에서 자리를 바꾸는 규칙 블록 암호 평문을 일정한 크기의 블록으로 잘라낸 후 암호화 알고리즘을 적용하여 암호화 어느 특정 비트 수의 집합 을 한번에 처리하는 암호 알고리즘 스트림 암호 데이터 흐름(스트림)을 순차적으로 처리해가는 암호 알고리즘의 총칭히며, 암호화 방식은 평문과 키 스트림을 XOR하여 생성 링크 암호화 헤더를 포함한 모든 데이터를 암호화 물리 계층과 데이터 링크 계층에서 암호화 종단간 암호화 헤더(라우팅)는 암호화 하지 않음 애플리케이션 계층에서 암호화 하드웨어 암호 시스템컴퓨터와 통신기기의 내부 버스와 외부 인터페이스에 전용 암호 처리용 하드웨어를 설치하여 데이터를 암호화 소프트웨어 암호 시스템암호처리용 소프트웨어를 사용한 데이터 암호화 중요 암호기술에 대한 개괄 대칭키 암호 : 암호화 할 때 사용하는 키와 복호화 할때 사용하는 키가 동일 비대칭키 암호 : 암호화 할 때 사용하는 키와 복호화 할 때 사용하는 키가 다름 암호학자의 도구상자 하이브리드 암호시스템 : 대칭키 암호 + 공개키 암호 일방향 해시함수 : 해시 값 메시지 인증코드 : 무결성, 인증제공 전자서명 스푸핑, 변경, 부인 이라는 위협 방지 무결성 확인, 인증과 부인 방지 의사 난수 생성기 : 키 생성 기타 암호 기술들 스테가노 그래피전달하려는 기밀 정보를 이미지 파일이나 MP3 파일 중에 암호화 해 숨기는 심층 암호 기술 감추어진 기록 워터마크원본의 내용을 왜곡하지 않는 범위 내에서 혹은 사용자가 인식하지 못하도록 저작권 정보를 디지털 콘텐츠에 삽입하는 기술 핑거프린팅디지털 콘텐츠를 구매할 때 구매자의 정보를 삽입하여 불법 배포 발견시 최초의 배포자를 추적할 수 있게 하는 기술 암호 분석(암호 해독) 개요 정규참여자가 아닌 제 3자가 암호문으로 부터 평문을 찾으려는 시도 케르히 호프의 원리암호 시스템의 안정성은 암호 알고리즘의 비밀을 지키는데 의존되어서는 안되고, 키의 비밀을 지키는데 의존되어야 한다는 원리 암호 분석의 분류 암호문 단독 공격(COA, Ciphertext Only Attack) 어떤 암호문을 얻어서 대응되는 평문과 키를 찾는 것 기지 평문 공격(KPA, ) 여러개의 평문/암호문의 쌍을 얻어 Alice -&gt; Bob 다음 메시지 알아내는데 사용 선택 평문 공격(CPA) Eve가 Alice의 컴퓨터에 접속할 수 있다면 공격자는 평문/암호문 쌍으로 평문에 해당하는 암호문을 얻어 키나 평문을 추정하여 암호 해독 선택 암호문 공격(CCA) Eve가 Bob의 컴퓨터에 접속할 수 있다면 암호해독자가 암호 복호기에 접근 할 수 있어 암호문을 선택하면 그 암호문에 대한 평문을 얻어 암호를 해독","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | start","slug":"0-security-start","date":"2017-09-03T07:06:19.000Z","updated":"2017-09-04T02:26:23.000Z","comments":true,"path":"2017/09/03/0-security-start/","link":"","permalink":"https://youngi08.github.io/2017/09/03/0-security-start/","excerpt":"","text":"","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"보안 | 정보보호관리의 개념","slug":"1-security-overview","date":"2017-09-03T07:04:53.000Z","updated":"2017-09-03T08:37:47.000Z","comments":true,"path":"2017/09/03/1-security-overview/","link":"","permalink":"https://youngi08.github.io/2017/09/03/1-security-overview/","excerpt":"","text":"정보보호 정보의 수집, 가공, 저장, 검색, 송민, 수신 중에 발생하는 정보의 훼손, 변조, 유출 등을 방지하기 위한 관리적, 기술적 수단, 또는 그러한 수단으로 이루어지는 행위 정보의 가용성, 보안 측면에서 정보보호란 정보의 활용과 정보의 통제 사이에서 균형감각을 갖는 행위 정보 보호의 목표 기밀성 (Confidentiality) 오직 인가된 사람, 프로세스, 시스템 만이 알 필요성에 근거하여 시스템에 접근해야 한다는 형식 비 인가된 접근으로부터 안전해야 함 무결성 (Integrity) 네트워크를 통하여 송수신 되는 정보의 내용이 불법적으로 생성 또는 변경 되거나 삭제 되지 않도록 보호되어야 하는 성질 비인가된 변경으로 부터 보호되어야 함 가용성 (Availability) 시스템에 지체 없이 동작하도록 하고, 합법적 사용자가 서비스 사용을 거절 당하지 않도록 하는 것 필요할 때 권한이 있는 사용자가 이용할 수 있어야 함 보안 공격(Security attack) 기밀성을 위협하는 공격 스누핑 (Snooping)데이터에 대한 비인가 접근 또는 탈취 트래픽 분석 (Traffic Analysis)데이터를 암호화하여 도청자가 그 데이터를 이해할 수 없게 해도 도청자는 온라인 트래픽을 분석함으로써 다른 형태의 정보를 얻을 수 있다 무결성을 위협하는 공격 변경(메시지 수정) 가장(신분 위장) 재연(재전송) 부인메시지 송신자는 차후에 자신이 메시지를 보냈다는 것을 부인할 수도 있고, 메시지의 수신자는 차후에 메시지를 받았다는 것을 부인할 수 있다 가용성을 위협하는 공격 서비스 거부(Dos)시스템의 서비스를 느리게 하거나 완전히 차단 할 수 있다 소극적 공격과 적극적 공격 소극적 공격(Passive Attack) 소극적 공격에서 공격자의 목표는 단지 정보를 획득하는 것 이는 공격자가 데이터를 변경하거나 시스템에 해를 끼치지 않는 다는 것을 의미한다 적극적 공격(Active Attack) 적극적 공격은 데이터를 바꾸거나 시스템에 해를 입힐 수 있다 공격자가 다양한 방법을 사용하기 때문에 방어하기 보다 탐지하는 것이 더 쉽다 기본 보안용어 정의 자산(Asset) 조직이 보호해야 할 대상으로서 데이터 혹은 자산 소유자가 가치를 부여한 실체 취약점(Vulnerability) 위협의 이용대상으로 관리적, 물리적 기술적 약점 위협(Threat) 보안을 침해하고 손해를 가져올 수 있는 상황, 행위, 이벤트가 존재할 떄의 잠재적 보안 위반 가로채기, 가로막음, 변조, 위조 위험(Risk) 특정 위협이 가져올 피해가 확률적으로 표현되는 예상 손실 노출(Exposure) 위협 주체에게 손실을 드러내 보이는 경우 취약점은 발생 가능한 피해를 노출 시킨다 시점별 통제(Control) 취약점을 감소 시키거나 억제하기 위해 사용되는 메커니즘을 통틀어 일컫는 말 예방통제, 탐지통제, 교정통제","categories":[{"name":"security","slug":"security","permalink":"https://youngi08.github.io/categories/security/"}],"tags":[]},{"title":"크로미움 안드로이드 버전 빌드","slug":"chromium-android-build","date":"2017-08-31T06:12:46.000Z","updated":"2017-08-31T06:39:55.000Z","comments":true,"path":"2017/08/31/chromium-android-build/","link":"","permalink":"https://youngi08.github.io/2017/08/31/chromium-android-build/","excerpt":"","text":"https://www.chromium.org/developers/how-tos/android-build-instructions 사실 저 위에 내용이 다 나와 있지만 헷갈리니 보기 쉽게 설명! depot_tools package 설치 1https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up 소스코드 다운로드! 12$ mkdir ~/chromium &amp;&amp; cd ~/chromium~/chromium$ fetch --nohooks android # This will take 30 minutes on a fast connection 만약 Linux 버전으로 checkout 된 버전이 존재한다면 fetch하지 않고 .gclient 파일에 target_os = [‘android’]를 추가해주면 된다. 소스코드 빌드하기Chromium을 빌드 할 수 있는 방법은 두가지가 있다.GYP build와 GN build가 있는데, 나는 GYP build로! (원래는 GYP build도 됬었는데, 현재는 제대로 지원안하는 것 같고 GN build로 해야 제대로 되는 것 같다) GYP Build 12~/chromium$ echo \"&#123; 'GYP_DEFINES': 'OS=android target_arch=arm', &#125;\" &gt; chromium.gyp_env~/chromium$ gclient runhooks GN Build 123$ export GYP_CHROMIUM_NO_ACTION=1$ ~/chromium/src$ gn args out/Default# out 뒤 폴더명은 Default 대신 다른이름으로 대체가능 1234#파일이 열리면 입력target_os = \"android\"target_cpu = \"arm\" # (default)is_debug = true # (default) 빌드 dependencies 설정 12#빌드에 필요한 시스템 패키지 업데이트~/chromium$ src/build/install-build-deps-android.sh OpenJDK 설정 업데이트-&gt; 없으면 설치법은 (https://www.davidlab.net/ko/tech/how-to-setup-android-dev-env-on-ubuntu-part1/) 123456sudo update-alternatives --config javacsudo update-alternatives --config javasudo update-alternatives --config javawssudo update-alternatives --config javapsudo update-alternatives --config jarsudo update-alternatives --config jarsigner 하위 디렉토리 동기화 1~/chromium/src$ gclient sync APK 빌드&amp; 설치 1~/chromium/src$ . build/android/envsetup.sh device 연결 됬는지 확인! 1third_party/android_tools/sdk/platform-tools/adb devices 빌드를 full browser, Content shell, Webview shell 버전 각각 다르게 할 수 있다. Full browser 빌드 12~/chromium/src$ ninja -C out/Release chrome_public_apk~/chromium/src$ build/android/adb_install_apk.py out/Release/apks/ChromePublic.apk # For gyp 다른 버전들 빌드 방법은 위에 있는 크로미움 사이트에서 확인가능! 설치12~/chromium/src$ build/android/adb_install_apk.py out/Release/apks/ChromePublic.apk # For gyp.~/chromium/src$ CHROMIUM_OUTPUT_DIR=$gndir build/android/adb_install_apk.py $gndir/apks/ChromePublic.apk # For gn","categories":[{"name":"chromium","slug":"chromium","permalink":"https://youngi08.github.io/categories/chromium/"}],"tags":[{"name":"android","slug":"android","permalink":"https://youngi08.github.io/tags/android/"},{"name":"chromium","slug":"chromium","permalink":"https://youngi08.github.io/tags/chromium/"}]},{"title":"알고리즘 | 선택정렬","slug":"algorithm-selection-sort","date":"2017-08-31T06:08:32.000Z","updated":"2017-09-03T12:09:54.000Z","comments":true,"path":"2017/08/31/algorithm-selection-sort/","link":"","permalink":"https://youngi08.github.io/2017/08/31/algorithm-selection-sort/","excerpt":"","text":"선택 정렬(Selection Sort) 정렬 되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환해나가는 방식 선택 정렬의 비교 횟수= (n-1) + (n-2) + (n-3) + … + 1= n(n-1)/2 시간 복잡도 평균, 최악, 최고: O(n^2) 기존의 레코드들이 정렬이 되어 있던, 되어 있지 않던 상관 없이 레코드들의 가장 처음부터 끝까지 비교하는 과정이 모두 같기 때문 동작원리 배열의 첫원소를 key값으로 설정하고 나머지 배열 원소 중 가장 작은 원소를 찾아 교체한다. 교체후에 첫 원소를 제외한 두번째 원소를 키 값으로 설정하고 1단계를 반복한다. 나머지 리스트를 모두 정렬이 될 때까지 1, 2 단계를 반복하여 정렬을 완료한다. 예제코드 1234567891011121314151617void selectionSort()&#123; intDataSet[]=&#123;6,4,2,3,1,5&#125;; int i, j, indexMin, temp; for(i =0; i &lt; n-1; i++)&#123; indexMin=i; for(j = i+1; j &lt; n; j++)&#123; if(list[j] &lt; DataSet[indexMin])&#123; indexMin = j; &#125; &#125; temp=DataSet[indexMin]; DataSet[indexMin]=DataSet[i]; DataSet[i]=temp; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"},{"name":"sort","slug":"algorithm/sort","permalink":"https://youngi08.github.io/categories/algorithm/sort/"}],"tags":[{"name":"sort","slug":"sort","permalink":"https://youngi08.github.io/tags/sort/"}]},{"title":"알고리즘 | 삽입정렬","slug":"algorithm-insert-sort","date":"2017-08-31T05:41:31.000Z","updated":"2017-09-03T12:09:27.000Z","comments":true,"path":"2017/08/31/algorithm-insert-sort/","link":"","permalink":"https://youngi08.github.io/2017/08/31/algorithm-insert-sort/","excerpt":"","text":"삽입정렬(Insert Sort) 데이터 집합을 순회하면서 정렬이 필요한 요소를 뽑아내어 이를 다시 적당한 곳에 삽입해 나가는 알고리즘 아직 정렬 되지 않은 임의의 데이터를 이미 정렬 된 부분의 적절한 위치에 삽입해가며 정렬하는 방식 시간 복잡도 최선 list가 이미 정렬 되어 있는 경우에는 외부 루프 n-1번만 실행되고 각 단계에서 데이터의 이동 없이 1번의 비교 연산만 수행 삽입 정렬은 비교적 정렬이 된 리스트에서는 이동 횟수가 선택 정렬과 버블 정렬에 비해 적게 일어난다는 장점 O(n) 최악 오름차순으로 정렬해야 하는 데이터가 역순으로 내림차순으로 정렬 되어 있다면 각 단계에서 앞에 놓인 데이터들은 전부 한 칸씩 뒤로 이동 해야하고, 외부 루프 안의 각 반복마다 i번 비교가 수행 따라서 데이터의 수가 많고 크기가 큰 경우에는 적합하지 않음 O(n^2) 동작원리 key 값을 기준으로 key의 앞은 정렬이 된 상태이다. i번째 요소를 정렬을 하기 위해서 i번째 배열의 값을 key로 저장을 한다. key값을 기준으로 i-1부터 검사를 하며 key 값보다 값이 클 경우 값을 한 칸씩 오른쪽으로 이동 시킨다. key 값보다 작거나 같은 값이 나올 때까지 2번 과정을 반복한다. 3번 과정에서 key값이 들어갈 위치를 찾으면 key값을 위치에 삽입한다. i+1 번째 배열의 값을 key로 저장 하며 모든 레코드가 정렬될 때 까지 1번 과정부터 반복 예제코드 1234567891011void insertSort()&#123; intDataSet[]=&#123;6,4,2,3,1,5&#125;; for(inti=1; i&lt;n; i++)&#123; key=DataSet[i]; //두 번째 값부터 선택 for(intj=i-1; j&gt;=0&amp;&amp;list[j]&gt;key; j—-)//선택된 값(key)보다 작은 값을 찾는다 DataSet[j+1]=DataSet[j];// 작은 값을 찾은 경우 그 값뒤의 모든 값을 우측으로 이동 DataSet[j+1]=key;//해당되는 곳에 값을 삽입 &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"},{"name":"sort","slug":"algorithm/sort","permalink":"https://youngi08.github.io/categories/algorithm/sort/"}],"tags":[{"name":"sort","slug":"sort","permalink":"https://youngi08.github.io/tags/sort/"}]},{"title":"알고리즘 | 버블정렬","slug":"algorithm-bubbule-sort","date":"2017-08-31T04:01:03.000Z","updated":"2017-09-04T02:25:40.000Z","comments":true,"path":"2017/08/31/algorithm-bubbule-sort/","link":"","permalink":"https://youngi08.github.io/2017/08/31/algorithm-bubbule-sort/","excerpt":"","text":"버블정렬(Bubble Sort) 데이터 집합을 순회하면서 집합 내의 이웃 요소들끼리의 교환을 통해 정렬을 수행 제일 큰 원소를 오른쪽으로 옮기는 방법 버블 정렬의 비교 횟수= (n-1)+(n-2)+…+(n-(n-2))+(n-(n-1))= (n-1)+(n-2)+…+3+2+1 = (n-1)(n/2)비교횟수 T(n)= (n(n-1))/2 시간복잡도 평균, 최악, 최고: O(n^2) 기존의 레코드들이 정렬이 되어 있던, 되어 있지 않던 상관 없이 레코드들의 가장 처음부터 끝까지 비교하는 과정이 모두 같기 때문 개선 방안 -&gt; 정렬되어있는 경우 루프를 취소하고 빠져나오도록 하는 방법 공간복잡도: O(1) 동작원리 이웃 하는 두 레코드를 비교하여 큰 레코드는 우측으로 밀어낸다. 더 이상 이웃 하는 레코드가 없을 때까지 반복한다. 리스트의 가장 우측부터 큰 레코드로 정렬이 된다. 모든 레코드가 정렬이 될 때까지 반복한다. 예제코드 12345678910111213141516void BubbleSort()&#123; int DataSet[]=&#123;6,4,2,3,1,5&#125;; int Length =sizeof(DataSet)/sizeof(DataSet[0]); for(int i=0; i&lt;Length-1; i++)&#123; for(int j=0; j&lt;Length-(i+1); j++)&#123; if(DataSet[j]&gt; DataSet[j+1])&#123; //인접한 두 값을 비교 //정렬되지 않은 두 값 temp = DataSet[j+1]; DataSet[j+1]=DataSet[j]; DataSet[j]=temp; &#125; &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"},{"name":"sort","slug":"algorithm/sort","permalink":"https://youngi08.github.io/categories/algorithm/sort/"}],"tags":[{"name":"sort","slug":"sort","permalink":"https://youngi08.github.io/tags/sort/"}]},{"title":"알고리즘 | start","slug":"algorithm-start","date":"2017-08-31T03:53:59.000Z","updated":"2017-08-31T07:10:59.000Z","comments":true,"path":"2017/08/31/algorithm-start/","link":"","permalink":"https://youngi08.github.io/2017/08/31/algorithm-start/","excerpt":"","text":"Categories 알고리즘 | 개념 자료구조의 분류 선형구조: 선형리스트(배열), 연결 리스트, 스택, 큐, 데크 비선형 구조: 트리, 그래프 정렬(Sorting) 알고리즘 | 정렬 시간복잡도 내부 정렬 소량의 데이터를 주기억장치에만 기억시켜서 정렬하는 방식 알고리즘 | 버블정렬 알고리즘 | 삽입정렬 알고리즘 | 선택정렬 알고리즘 | 퀵정렬 알고리즘 | 합병정렬 알고리즘 | 2-Way 합병 정렬 외부 정렬 대량의 데이터를 보조기억장치에 기억시켜서 정렬하는 방식 대부분 합병정렬(Merge Sort) 기법으로 처리","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://youngi08.github.io/tags/algorithm/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-30T17:55:34.000Z","updated":"2017-08-31T02:22:19.000Z","comments":true,"path":"2017/08/31/hello-world/","link":"","permalink":"https://youngi08.github.io/2017/08/31/hello-world/","excerpt":"","text":"기존 블로그와 에버노트에서 이전중~http://kisys.tistory.com/","categories":[],"tags":[]},{"title":"odroid에 구글 크로미움 포팅하기","slug":"odroid-porting-chromium","date":"2017-08-30T09:41:31.000Z","updated":"2017-08-31T07:20:14.000Z","comments":true,"path":"2017/08/30/odroid-porting-chromium/","link":"","permalink":"https://youngi08.github.io/2017/08/30/odroid-porting-chromium/","excerpt":"","text":"삽질한 것에 비해 굉장히 간단한 방법으로 할 수 있다. 여기에 몇 일을 날렸는가…ㅠㅠ먼저 원리를 제대로 이해하고 했으면 삽질이라고 할 수도 없을 만큼 빠른 시간 안에 할 수 있었을 것이다. 방향을 이상하게 잡아서 삽질하다 보니 굉장히 오래 걸리게 되었다. odroid xu3 보드에 크로미움을 포팅하기 위해서는 arm 32bit용으로 컴파일 해야 한다. Hardkernel 사이트에서 크로스컴파일을 위한 툴체인, 환경을 세팅한다. 내 보드는 xu3이다.http://odroid.com/dokuwiki/doku.php?id=en:xu3_building_kernel 크로미움 크로스컴파일 하기http://unix.stackexchange.com/questions/176794/how-do-i-cross-compile-chromium-for-arm위 사이트 참조! 크로미움 코드를 다운로드 하기 위한 과정은 같다.(1) depot_tools 설치12$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools$ export PATH=$PATH:~/chromium/depot_tools (2) 크로미움 코드 다운로드12$ mkdir chromium &amp;&amp; cd ~/chromium$ fetch --nohooks chromium (3)ARM용 컴파일https://www.olimex.com/forum/index.php?topic=4109.01234./build/install-build-deps.sh --arm &amp;&amp;gclient sync &amp;&amp;GYP_CROSSCOMPILE=1 GYP_DEFINES=\"target_arch=arm arm_float_abi=hard component=shared_library linux_use_gold_flags=1\" gclient runhooks &amp;&amp;ninja -C out/Release chrome","categories":[{"name":"odroid","slug":"odroid","permalink":"https://youngi08.github.io/categories/odroid/"}],"tags":[{"name":"chromium","slug":"chromium","permalink":"https://youngi08.github.io/tags/chromium/"},{"name":"odroid","slug":"odroid","permalink":"https://youngi08.github.io/tags/odroid/"}]},{"title":"Hexo | 마크 다운 문법 정리","slug":"markdown-grammer","date":"2017-08-30T08:28:01.000Z","updated":"2017-11-24T09:35:46.936Z","comments":true,"path":"2017/08/30/markdown-grammer/","link":"","permalink":"https://youngi08.github.io/2017/08/30/markdown-grammer/","excerpt":"","text":"글자 서식 &lt;__문자__&gt; 강조 &lt;_문자_&gt; 기울림 &lt;~~문자~~&gt; 취소 수식 윗 첨자와 아래 첨자 &lt;sup&gt; 윗 첨자sup &lt;sub&gt; 아래 첨자sub 사선 그림 삽입 ! [] (images/image.png) (링크)","categories":[{"name":"web","slug":"web","permalink":"https://youngi08.github.io/categories/web/"},{"name":"hexo","slug":"web/hexo","permalink":"https://youngi08.github.io/categories/web/hexo/"}],"tags":[]},{"title":"Tizen | print-service not found 에러","slug":"tizen-print-service-not-found-error","date":"2015-09-22T04:39:56.000Z","updated":"2017-09-04T02:31:33.000Z","comments":true,"path":"2015/09/22/tizen-print-service-not-found-error/","link":"","permalink":"https://youngi08.github.io/2015/09/22/tizen-print-service-not-found-error/","excerpt":"","text":"Tizen 코드를 repo sync로 받는데 중간에 에러가 나길래 repo sync -f로 강제로 받았는데 계속 같은 에러를 내뿜으면서 다운이 실패하였다. error: in sync -f: revision tizen in apps/core/preloaded/print-service not found print-service폴더는 있는데 안에 내용물이 없다. 왜 없어 ㅠㅠ https://review.tizen.org/git/ 1git clone ssh://&lt;username&gt;@review.tizen.org:29418/apps/core/preloaded/print-service.git 해서 그 디렉토리만 따로 다운 받으려고 했는데 이 방법도 에러나… 내가 잘못한건가… 그래서 그냥 원래 다운받아놨던 tizen 파일에서 print-service 디렉토리를 통째로 복사해서 다시 repo sync 했더니 제대로 된다. 아니 그럼 이걸 처음 다운 받는 사람들은 어떻게 문제 해결함ㅋㅋㅋㅋ 나도몰라 흐헣 왜 맨날 받을때마다 새로운 에러를 내뿜냐","categories":[],"tags":[]},{"title":"Tizen | ssh 설치 에러 해결법","slug":"tizen-ssh-install-error","date":"2015-09-22T03:10:34.000Z","updated":"2017-09-04T02:28:59.000Z","comments":true,"path":"2015/09/22/tizen-ssh-install-error/","link":"","permalink":"https://youngi08.github.io/2015/09/22/tizen-ssh-install-error/","excerpt":"","text":"Tizen에서 코드를 받을때permission denied (publickey). fatal could not read from remote repository와 같은 에러가 발생하였을때. 나는 gerrit사이트에 ssh public key를 등록했는데도 계속 같은 에러가 발생했다.tizen(gerrit) 사이트 계정 이름과 내 컴퓨터 계정이름이 달라도 에러가 발생 할 수 있다고 해서https://source.tizen.org/ko/documentation/developer-guide/environment-setup?langredirect=1위의 사이트 따라서 ~/.ssh/config 파일도 수정했는데 계속 문제 해결이 안됐다. 근데 이 코드 한줄만에 해결!1$ ssh-add","categories":[],"tags":[]},{"title":"Tizen | v8 build하기","slug":"tizen-v8-build","date":"2015-07-22T02:20:32.000Z","updated":"2017-09-04T02:28:22.000Z","comments":true,"path":"2015/07/22/tizen-v8-build/","link":"","permalink":"https://youngi08.github.io/2015/07/22/tizen-v8-build/","excerpt":"","text":"만약 64비트 환경이라면 먼저 설치하고 시작 하는 것이 정신건강에 좋음 ㅠㅠ (Ubuntu 14.04 기준)1$ sudo apt-get install bison g++-multilib git gperf libxml2-utils make python-networkx zlib1g-dev:i386 zip https://code.google.com/p/v8-wiki/wiki/UsingGit단순히 build만 할 경우에는 Prerequisites 2번의 depot_tools를 설치한 다음 How to Start로 넘어간다 https://code.google.com/p/v8-wiki/wiki/BuildingWithGYP","categories":[{"name":"tizen","slug":"tizen","permalink":"https://youngi08.github.io/categories/tizen/"}],"tags":[]},{"title":"Tizen | MIC를 이용한 Tizen Image 만들기","slug":"tizen-MIC-make-image","date":"2015-06-13T14:37:48.000Z","updated":"2017-09-04T02:33:07.000Z","comments":true,"path":"2015/06/13/tizen-MIC-make-image/","link":"","permalink":"https://youngi08.github.io/2015/06/13/tizen-MIC-make-image/","excerpt":"","text":"참고 사이트:https://source.tizen.org/ko/documentation/developer-guide/getting-started-guide/creating-tizen-images-michttps://wiki.tizen.org/wiki/Modify_Emulator_Image KickckStart File 다운로드http://download.tizen.org/ 에서 버전에 맞는 KickStart File을 다운로드 해야 한다. i586 mobile 버전 기준1$ wget http://download.tizen.org/snapshots/tizen/mobile/tizen-mobile_20150613.2/images/emulator32-wayland/mobile-emulator32-wayland/tizen-mobile_20150613.2_mobile-emulator32-wayland.ks Tizen Image 만들기 1$ gbs createimage --ks-file=tizen-mobile_20150613.2_mobile-emulator32-wayland.ks Emulator Image 수정하기tizen 다운받은 디렉토리안에 mic-output 폴더에서 ~.tar.gz 압축풀면 platform.img가 있다. -&gt; 최근 버전 경우(mobile)는 ~.tar.gz 압축을 풀면 emulator-rootfs.img emulator-sysdata.img emulator-user.img이 들어있다. 이 경우에는 qemu-img로 빌드 할때1$ ~/tizen-sdk/tools/emulator/bin/qemu-img convert -O qcow2 emulator-rootfs.img emulator-sysdata.img emulator-user.img emulimg.3.0.x86 하면 제대로 런치화면에서 작동한다. 빌드할때 자동으로 Emulator Image를 만들어주고 싶을때는1$ gbs build -A i586 -R http://download.tizen.org/snapshots/tizen/ivi/latest/repos/emulator/packages/ --define \"with emulator\" --overwrite --include-all Mobile 버전의 경우는 emulator도 32/64bit 로 나뉘어져있다. Tizen SDK에서 img파일을 열어주면 된다! https://wiki.tizen.org/wiki/Tizen_IVI_SDK 출처: http://kisys.tistory.com/entry/Tizen-MIC를-이용한-Tizen-Image-만들기 [HelloWorld!]","categories":[{"name":"tizen","slug":"tizen","permalink":"https://youngi08.github.io/categories/tizen/"}],"tags":[]},{"title":"Tizen | Tizen 코드 설치 및 빌드 방법","slug":"tizen-source-build","date":"2015-06-13T14:23:26.000Z","updated":"2017-09-04T02:21:01.000Z","comments":true,"path":"2015/06/13/tizen-source-build/","link":"","permalink":"https://youngi08.github.io/2015/06/13/tizen-source-build/","excerpt":"","text":"GBS, MICS 설치 123$ deb http://download.tizen.org/tools/latest-relase/Ubuntu_14.04 /$ sudo apt-get update$ sudo apt-get install gbs Tizen code repo (Tizen 3.0 기준) mobile 버전 1$ repo init -u ssh://&lt;username&gt;@review.tizen.org:29418/scm/manifest -b tizen -m mobile.xml ivi나 common버전을 받으려면 mobile.xml 대신 ivi.xml/common.xml로 받으면 된다. username은 Gerrit에 등록된 이름 1$ repo sync -j8 Build i586 아키텍처로 빌드1$ gbs build -A i586 --threads=4 --clean-once --exclude=gcc,cmake,filesystem,aul,libmm-sound,libtool -armv7l 아키텍처로 빌드123$ skip_pkgs=\"bash,bzip2-libs,c-ares,cmake,coreutils,diffutils,eglibc,elfutils-libelf,elfutilslibs,elfutils,fdupes,file,findutils,gawk,gmp,libacl,libattr,libcap,libcurl,libfile,libgcc,liblua,libstdc ++,make,mpc,mpfr,ncurses-libs,nodejs,nspr,nss-softokn-freebl,nss,openssl,patch,popt,rpmlibs,rpm-build,sed,sqlite,tar,xz-libs,binutils,gcc,filesystem,aul,libmm- sound,libtool,syspopup,notification,libva,libzypp-bindings,rpm\"$ gbs build -A armv7l --threads=4 --clean-once --exclude=$&#123;skip_pkgs&#125;,filesystem, aul, libmm-sound, libtool build완료하고 난 후에 error: some packages failed to be built 와 같은 에러가 발생하는데 이 에러는 무시해도 영향을 미치지 않는것 같다. 왜 이런 에러가 발생하는지는 모르겠다ㅠ ㅠㅠ Build가 완료되면 RPM파일이 생성되는데 이 파일은 ~/GBS-ROOT/local/repos/tizen3.0_mobile(자신이 받은 버전)/i586(빌드한 아키텍처처)/RPMS 디렉토리에서 확인 가능하다.","categories":[{"name":"tizen","slug":"tizen","permalink":"https://youngi08.github.io/categories/tizen/"}],"tags":[]},{"title":"Cordova | QR코드 리더 webApp","slug":"cordova-QRcodereader-webApp","date":"2015-06-13T13:35:51.000Z","updated":"2017-09-04T02:38:56.000Z","comments":true,"path":"2015/06/13/cordova-QRcodereader-webApp/","link":"","permalink":"https://youngi08.github.io/2015/06/13/cordova-QRcodereader-webApp/","excerpt":"","text":"개발 환경: Ubuntu Linux 14.04 LTS, Android Studio Plugin 추가먼저 plugin을 추가하기 위해서는 plugman을 설치해야 한다.1$ npm install -g plugman BarcodeScanner plugin 추가 1$ cordova plugin add https://github.com/wildabeast/BarcodeScanner.git InAppBrowser plugin 추가 1$ cordova plugin add cordova-plugin-inappbrowser user-permission 추가AndroidManifest.xml 파일에 uses-permission 추가123&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.FLASHLIGHT&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; index.js 12345678910111213141516171819202122232425262728293031323334353637var resultDiv;document.addEventListener(\"deviceready\", init, false);function init() &#123; document.querySelector(\"#startScan\").addEventListener(\"touchend\", startScan, false); resultDiv = document.querySelector(\"#results\");&#125; document.addEventListener(\"deviceready\", re, false);function startScan() &#123;인인 cordova.plugins.barcodeScanner.scan( function re (result) &#123; //바코드가 읽힌 결과 확인 /* var s = \"Result: \" + result.text + \"&lt;br/&gt;\" + \"Format: \" + result.format + \"&lt;br/&gt;\" + \"Cancelled: \" + result.cancelled; */ //바코드 읽은 결과를 실제 browser에 띄우기 var ref = window.open(result.text, '_self', 'location=no'); ref.addEventListener('loadstart', function(event) &#123; var urlSuccessPage = result.txt; if (event.url == urlSuccessPage) &#123; ref.close(); &#125; &#125;); alert('test'); &#125;, function (error) &#123; alert(\"Scanning failed: \" + error); &#125; );&#125; index.html12345&lt;button id=\"startScan\"&gt;Start Scan&lt;/button&gt;&lt;div id=\"results\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"barcodescanner.js\"&gt;&lt;/script&gt;","categories":[{"name":"cordova","slug":"cordova","permalink":"https://youngi08.github.io/categories/cordova/"}],"tags":[]},{"title":"Cordova | Keystore 생성하기","slug":"cordova-create-keystore","date":"2015-06-08T06:00:46.000Z","updated":"2017-09-04T02:43:14.000Z","comments":true,"path":"2015/06/08/cordova-create-keystore/","link":"","permalink":"https://youngi08.github.io/2015/06/08/cordova-create-keystore/","excerpt":"","text":"코도바를 빌드해서 apk파일을 ADB를 통해 install했더니 error가 발생했다.phonegapp 프로젝트 폴더에 keystore파일을 만들어야 한다. 1$ keytool -genkey -v -keystore [keystore name].keystore -alias [alias name] -keyalg RSA -keysize 3048 -validity 10000 (keystore 파일 유효기간)","categories":[{"name":"cordova","slug":"cordova","permalink":"https://youngi08.github.io/categories/cordova/"}],"tags":[]},{"title":"Tizen | 타이젠 설치법","slug":"tizen-install","date":"2015-05-28T14:36:59.000Z","updated":"2017-09-04T02:29:17.000Z","comments":true,"path":"2015/05/28/tizen-install/","link":"","permalink":"https://youngi08.github.io/2015/05/28/tizen-install/","excerpt":"","text":"타이젠 웹사이트 계정 생성 및 Gerrit등록, 소스코드 다운 받는 법을 자세히 알려준 블로그!설치중 발생하는 에러 상황 대처법까지 자세히 정리되어있다. http://seoz.egloos.com/3913161 http://miatistory.tistory.com/6","categories":[{"name":"tizen","slug":"tizen","permalink":"https://youngi08.github.io/categories/tizen/"}],"tags":[]},{"title":"Cordova | Linux에서 Cordova 개발환경 설치","slug":"cordova-linux-install","date":"2015-05-25T13:41:58.000Z","updated":"2017-09-04T02:40:59.000Z","comments":true,"path":"2015/05/25/cordova-linux-install/","link":"","permalink":"https://youngi08.github.io/2015/05/25/cordova-linux-install/","excerpt":"","text":"Cordova Documentation: http://cordova.apache.org/docs/en/3.3.0/guide_cli_index.md.html#The%20Command-Line%20Interface Android studio 설치https://developer.android.com/sdk/index.html npm과 nodejs설치 123$ sudo add-apt-repository ppa:chris-lea/node.js$ sudo apt-get install nodejs$ sudo apt-get install npm npm을 통해 cordova 설치 1$ sudo npm install -g cordova 프로젝트 생성 12$ cordova create &lt;생성할 프로젝트 디렉토리&gt; &lt;APP_ID&gt;&lt;Bundle Display Name&gt;//$ cordova create test com.test.app app 만약 아래와 같은 오류가 발생한다면 node.js의 path가 지정되지 않은 것이다./usr/bin/env: node :No such file or directory 다음 명령어를 실행한다.1$ sudo ln -s /usr/bin/nodejs /usr/bin/node *cordova platform add android 를 했을때 Unable to fetch platform android: Error: EACCES, mkdir ‘/home/user/tmp/npm-12074-rNPOjSs_’와 같은 에러가 뜨는 것은 /home/user/tmp에 권한이 없는것이다. 그럴때는 권한을 주면 된다!1$ sudo chown user /home/user/tmp -RV 사용할 플랫폼 추가 123$ cd test(생성한 프로젝트 디렉토리)$ cordova platform add &lt;target platform&gt;//$ cordova platform add android Emulator or Device에 테스트하기Android Studio에서 Import project(Eclipse ADT, Gradle, etc.) 1$ test/platforms/android APACHE CORDOVA DEVICE IS READY 화면이 뜨면 성공! assets/www/ 디렉토리 밑에 HTML5, CSS3, javascript등의 파일을 이용해서 화면을 넣어주면 된다!","categories":[{"name":"cordova","slug":"cordova","permalink":"https://youngi08.github.io/categories/cordova/"}],"tags":[]}]}